<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 且徐行</title>
    <link>https://blog.cc1234.cc/tags/spring/</link>
    <description>Recent content in Spring on 且徐行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 May 2020 11:40:46 +0800</lastBuildDate><atom:link href="https://blog.cc1234.cc/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring Ant-Style Matcher 笔记</title>
      <link>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</link>
      <pubDate>Mon, 04 May 2020 11:40:46 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</guid>
      <description>Spring Ant-Style Matcher 笔记 在使用 Spring 的时候经常会写路径相关的配置，比如
 @RequestMapping 中配置请求路径 @ComponentScan 中配置包路径 为 Interceptor 配置规则 &amp;hellip;&amp;hellip;  而这些路径的配置规则中，我们经常会看见 、* 等类似于正则表达式的符号，这实际上就是 Spring 的路径匹配规则。
Spring 默认有一个 AntPathMatcher 类用于处理这类路径的规则匹配， 它借鉴了 Ant 的实现（如果你感兴趣的话，可以在点击这里进行了解），这也是为什么称之为 Ant-Style 的原因。
 题外话：Ant 是一个自动化构建工具，最开始是为了解决 Tomcat 的构建问题而诞生的
 Ant 本身是定义了三种匹配规则，而 spring 在此基础之上额外扩展了一种，参考下面的表格
         ? 匹配单个字符   * 匹配 0 个或多个字符   ** 匹配 0 个或多个目录   {spring: [a-z]+} 匹配正则表达式 [a-z]+, 将匹配后的路径作为 spring 的变量    下面的表格展示了一个具体的实例</description>
    </item>
    
  </channel>
</rss>
