<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 且徐行</title>
    <link>https://blog.cc1234.cc/tags/java/</link>
    <description>Recent content in Java on 且徐行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.cc1234.cc/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>我是如何开发了一款‘有人用’的开源软件</title>
      <link>https://blog.cc1234.cc/posts/how-to-develop-prettyzoo/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/how-to-develop-prettyzoo/</guid>
      <description>我是如何开发了一款“有人用”的开源软件 背景 PrettyZoo 是在去年国庆（2019 年）时开发的一个用于管理 Zookeeper 的桌面图形化工具，当时是因为在学习 Elastic-Job-Lite 框架的源码时涉及到了 Zookeeper，想着借助图形化工具去更直观的了解整个框架的设计，但在市面上却找不到一款符合自己期望的产品，那就只能自己动手丰衣足食了，这算是 PrettyZoo 诞生的初衷了。
其实我已经写过一篇文章来简单介绍过这个产品的研发历程（从 Java8 到 Java11 ： PrettyZoo 开发回顾（模块化在 GUI 中的实践））, 不过那篇文章主要侧重于产品的技术演进过程，这一篇文章是基于国庆重构后的全新版本来写的，记录了自己在这个重构的过程中各个阶段所做的事情，主要包括以下内容
 需求分析 原型设计 技术选型 架构设计 成品展示  需求分析 上一节的背景描述了我为什么要开发这样一款软件，而这一节的主要内容则是分析我想要开发的软件应该有的功能点。
该产品是用于管理 Zookeeper 数据，那么需求其实也需要围绕着 Zookeeper 的功能来分析，这就像为人作肖像画一样，得先去分析目标的特性。
我将分析后的需求整理成了下面的一个表格，并对功能的优先级、必要性做了标注
   需求 优先级 是否必须     连接创建 高 √   连接删除 高 √   节点展示 高 √   节点创建 高 √   节点删除 高 √   节点数据更新 高 √   递归操作支持 中 √   节点数据格式化（JSON、YAML） 低 ×   SSH Tunnel 支持 中 ×   ACL 支持 中 √   配置导入/导出 中 ×         当然实际的产品开发中还会去调查类同类产品，去参考它们的功能、设计等， 这方面我就略过了。</description>
    </item>
    
    <item>
      <title>Spring Ant-Style Matcher 笔记</title>
      <link>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</link>
      <pubDate>Mon, 04 May 2020 11:40:46 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</guid>
      <description>Spring Ant-Style Matcher 笔记 在使用 Spring 的时候经常会写路径相关的配置，比如
 @RequestMapping 中配置请求路径 @ComponentScan 中配置包路径 为 Interceptor 配置规则 &amp;hellip;&amp;hellip;  而这些路径的配置规则中，我们经常会看见 、* 等类似于正则表达式的符号，这实际上就是 Spring 的路径匹配规则。
Spring 默认有一个 AntPathMatcher 类用于处理这类路径的规则匹配， 它借鉴了 Ant 的实现（如果你感兴趣的话，可以在点击这里进行了解），这也是为什么称之为 Ant-Style 的原因。
 题外话：Ant 是一个自动化构建工具，最开始是为了解决 Tomcat 的构建问题而诞生的
 Ant 本身是定义了三种匹配规则，而 spring 在此基础之上额外扩展了一种，参考下面的表格
         ? 匹配单个字符   * 匹配 0 个或多个字符   ** 匹配 0 个或多个目录   {spring: [a-z]+} 匹配正则表达式 [a-z]+, 将匹配后的路径作为 spring 的变量    下面的表格展示了一个具体的实例</description>
    </item>
    
    <item>
      <title>HashMap 的细节笔记</title>
      <link>https://blog.cc1234.cc/posts/hashmap-some-detail/</link>
      <pubDate>Mon, 27 Apr 2020 21:19:45 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/hashmap-some-detail/</guid>
      <description>HashMap 的细节笔记 HashMap 的节点转为红黑树以后，树形节点之间是基于什么来比较的呢？ 首先会根据 key 的 Hash 值来进行比较，如果相等的话，会再判断 key 是否实现了 Comparable 接口，如果是的话，可以直接通过 compareTo 方法进行比较。
如果 hash 值相等，而且也没有实现Comparable 接口呢？此时会对 key 对象使用 System.identityHashCode(key) 进行再次 hash 运算，最后再根据新的 hash 值进行比较。
那么 System.identityHashCode 又是什么操作呢？
这是一个 native 的方法，实现的原理也很简单，就是不管你对象有没重写 hashCode 函数，它都只返回对象默认的 hashCode 值。
为什么 HashMap 的链表节点冲突数达到 8 才会转为红黑树？ 在 hashmap 的源码注释中有一段 Implementation notes， 里面有提到具体的决策原因。
虽然红黑树的查询事件复杂度是 logN, 但是红黑树节点的 size 大概是普通节点的 2 倍，而且在插入效率方面，红黑树的插入时间复杂度为 logN, 链表的插入节点时间复杂度是 O (1)。
综上所述，实则是一个时间和空间的决策，那么为什么是 8 呢？
如果 key 的 hash 值分布的足够均匀，几乎不会转换成树形节点。
假设使用随机的 hash 算法，理想情况下，通过泊松分布的概率函数可以计算某个桶位冲突节点达到 K 个的概率，设 λ = 0.</description>
    </item>
    
    <item>
      <title>从 Java8 到 Java11 ： PrettyZoo 开发回顾（模块化在 GUI 中的实践）</title>
      <link>https://blog.cc1234.cc/posts/java-gui-experience/</link>
      <pubDate>Sun, 12 Apr 2020 12:30:37 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/java-gui-experience/</guid>
      <description>从 Java8 到 Java11 ： PrettyZoo 开发回顾（模块化在 GUI 中的实践） 起因 elastic-job-lite 是公司使用的一款定时任务调度框架，该框架将所有的任务调度信息都注册进了 zookeeper 中。
为了方便定位相关的问题，我去网上搜了 zookeeper 相关的图形化客户端，结果没有一款符合自己的需求，于是就干脆自己写一个算了。
 该客户端是去年国庆假期写的，经历了从 Java8 到 Java11 的重构（主要是模块化），该文章主要是对整个过程的一个回顾
 从需求分析到实现 面向用户：zookeeper 用户
软件名称：PrettyZoo
功能：
 节点 CRUD 节点实时同步  交互与原型：
交互分两部，第一步启动页面要求用户输入 zookeeper 的服务地址，连接成功后会跳到节点操作页面
​	技术方案：
 语言采用 Java UI 框架采用 Swing 采用传统的分层架构 Zookeeper Client 采用 Apache Curator  最终实现：
​	不足：
 受限于交互流程，一次只能管理一个 zookeeper server 由于是 Java8，运行需要安装额外的 JRE（或 JDK），影响了受众面 颜值不足 工程质量方面，架构分层不清晰，导致层与层之间相互渗透，随时膨胀为一个 Big Bom  界面与架构的重构规划 重构主要是为了解决上一版的不足，而第一步就是分析产生这些问题的根本原因，再提出对应的解决方案</description>
    </item>
    
  </channel>
</rss>
