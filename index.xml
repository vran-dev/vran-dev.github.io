<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>且徐行</title>
    <link>https://blog.cc1234.cc/</link>
    <description>Recent content on 且徐行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Jan 2023 22:39:08 +0800</lastBuildDate><atom:link href="https://blog.cc1234.cc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring6 新特性之 Http Interface Client 初探</title>
      <link>https://blog.cc1234.cc/posts/spring6-http-interface/</link>
      <pubDate>Tue, 03 Jan 2023 22:39:08 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/spring6-http-interface/</guid>
      <description>前言 Spring Cloud 在 2022.0.0 版本 Release 的时候宣布 Spring Cloud Openfeign 进入维护模式了：不再添加新特性，只处理 bug 修复、安全修复以及社区 PR 审查。
Since Spring now provides its own interface HTTP clients solution, starting with 2022.0.0, we’re going to treat Spring Cloud OpenFeign as feature complete. This means that the Spring Cloud team will no longer be adding new features to the module. We will still fix bugs and security issues, and we will also consider and review small pull requests from the community.</description>
    </item>
    
    <item>
      <title>PrettyZoo 2.0 重大更新，支持暗黑模式</title>
      <link>https://blog.cc1234.cc/posts/prettyzoo-2/</link>
      <pubDate>Sun, 20 Nov 2022 14:00:43 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/prettyzoo-2/</guid>
      <description>前言 PrettyZoo 有一段时间没有发布新版本了，一个是因为功能基本能满足 90% 的使用场景，另一个是因为我个人最近这段时间的事情也比较多。
这两天因为身体的一些运动损伤导致只能宅家休息，借此机会就将历史问题修复了一番，整个 UI 也做了大的改造
新特性概览 全新的 UI 设计 支持暗黑模式 支持配置 zookeeper 连接超时时间 支持配置 zookeeper 系统环境变量 支持手动检测版本更新 其他历史遗留 bug 修复 全新的 UI 设计 这个版本将大部分 UI 都进行了重新设计，采用了更简洁的元素展示
SSH Tunnel 的表单默认会隐藏，只有在需要配置的情况下才会展示，减少了不必要的信息干扰
菜单的 UI 也做了统一的风格设计
重连会有明显的动态指示
暗黑模式 由于 PrettyZoo 默认采用的是白色主题，对眼睛的刺激表较大，为此这个版本特地增加了暗黑模式，为保护眼睛作出努力
连接超时时间配置 最开始社区经常会有用户反馈 zk 连接超时，我就将默认超时时间加到了 6s，在这个版本我将超时时间的控制权完全放给了用户
目前支持配置
连接超时时间 会话超时时间 重试间隔时间 最大重试次数 zookeeper 系统环境变量 zookeeper 有不少配置是通过环境变量来设置的，比如 jute.buffer ，在上个版本提供了加载指定目录下的 zookeeper.properties 的解决方案，这个版本再进一步：支持直接在客户端配置
版本更新检测 老版的版本更新检测实在是太简陋了，新版做了重新设计，用户可以主动点击检测更新
如果有新版本，点击 icon 即可查看新版本特性，在弹出的对话框点击 YES 即可跳转到软件下载页面
其他 除了以上的新特性外，这个版本还修复了不少历史 BUG，在此就不一一列举了，如果有兴趣可以到 Release 页面下载体验</description>
    </item>
    
    <item>
      <title>写几个插件让 Mybatis generator 更好用！</title>
      <link>https://blog.cc1234.cc/posts/mybatis-generator-continuous-plugin/</link>
      <pubDate>Sun, 03 Jul 2022 22:11:58 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/mybatis-generator-continuous-plugin/</guid>
      <description>前言 最近团队统一了技术栈，Mybatis 正是其中一项，为了加强自己的开发体验，我再度花时间研究了一下 Mybatis Generator 并开发了几款插件。
主要目标还是为了将有限的时间投入到高创造性的产出活动中（说的再高大上也是为了少写代码 ing），以及减少低级错误的发生。
本文就是对这几款插件的一个介绍，插件源码已经放在 github 上了
https://github.com/vran-dev/mybatis-generator-continuous-plugin 关于我是如何集成 generator 的，可以在 github 上查看另一个演示项目
https://github.com/vran-dev/mybatis-continuous-generate-integration-demo MapperPlusPlugin 当前问题 很多时候生成的代码并不能完全满足业务需求，需要对其进行一定的扩展，扩展的最基本原则就是不修改由 Mybatis generator 生成的文件，因为这样才能在项目迭代中持续的使用 Mybatis generator，降低因为修改冲突而带来的维护成本。
为了实现扩展，一般会选择继承由 generator 生成的 Java mapper 接口，然后再手写一个 XML，这个手写的 XML 可以通过 namespace + id 的形式引用生成的 XML 中的 、 等元素
&amp;lt;mapper namespace=&amp;#34;cc.cc1234.dao.mapper.UserMapper&amp;#34;&amp;gt; &amp;lt;select id=&amp;#34;selectByUsername&amp;#34; resultMap=&amp;#34;generated.UserGeneratedMapper.BaseResultMap&amp;#34;&amp;gt; select * from user where username = #{username} &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 但这种引用方式不是很便捷，如果能直接通过 id 引用而不需要加 namepace 前缀是最好的了。
&amp;lt;mapper namespace=&amp;#34;cc.cc1234.dao.mapper.UserMapper&amp;#34;&amp;gt; &amp;lt;!-- 期望直接通过 ID 应用 --&amp;gt; &amp;lt;select id=&amp;#34;selectByUsername&amp;#34; resultMap=&amp;#34;BaseResultMap&amp;#34;&amp;gt; select * from user where username = #{username} &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 其实 generator 生成的 Java Mapper 的方法都差不多（只是参数、返回值类型不同），完全可以将这些方法通过泛型设计放到一个通用的 BaseMapper 接口中去，那么扩展的时候就不是继承各自的 XxxMapper，而都是同一个 BaseMapper 了。</description>
    </item>
    
    <item>
      <title>如何入门产品的功能设计？《简约至上》读书笔记</title>
      <link>https://blog.cc1234.cc/posts/how-to-design-product/</link>
      <pubDate>Fri, 06 May 2022 09:31:29 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/how-to-design-product/</guid>
      <description>引言 谢邀，人在飞机，刚下海上。
《简约至上：交互式设计四策略》是最近读的一本指导产品设计的书，它对我的产品设计方法带来了很大的改变。
书中不仅有设计思维方面的内容，还有执行层面的方法论，让我一个完全依靠直觉和过往经验做功能设计的设计者初次感觉到设计也是有迹可循。
本文算是一篇读后感 + 笔记的混合文，大纲如下
功能和可用性到底哪一个更受用户关注？ 三类用户：主流、随意型、专家 为自己设计还是为用户设计？ 四策略：删除、组织、隐藏、转移 功能和可用性到底哪一个更受用户关注？ 书中展示了一个 2006 年的实验，该实验将用户分为两组去挑选功能数量不同的播放器
第一组（未试用组）：只能通过观察产品来做挑选 第二组（试用组）：可以试用产品以后再做挑选 播放器的规格如下
播放器 A：拥有 7 项功能 播放器 B：拥有 21 项功能 最终实验结果如下
选择播放器 A 的用户比例（7 项功能） 选择播放器 B 的用户比例（21 项功能） 未使用组 34% 66% 试用组 56% 44% 由结果可以看出对于没有机会试用的消费者而言，功能越多越能吸引用户注意；但是消费者使用了产品之后，他们的偏好就会从重视功能转为重视可用性了。
复杂的产品通常很吸引人，这是因为人们喜欢自己被包围在不必要的功能中。
当然这并不是说功能不重要，而是不要以功能的多寡来衡量产品的价值，这里引用一段原文作者的观点：
增加的功能越多，就越难发现真正对用户有价值的新功能。这样盲目添加的新功能早晚会成为垃圾功能。增加复杂性意味着遗留代码越来越沉重，导致产品维护成本越来越高，而且也越来越难以灵活应对市场变化。
复杂的功能会导致另一个问题：过多的功能选择会带给用户负担。
给用户提供选择会让人感觉自己在把控局面，但实际上主流用户更希望少一些选择，尤其是多种选择都很相似的情况下，选择就是一种负担。
简单的用户体验不会强迫用户去做这种选择，哪种方式最有效应该是设计者考虑的事情。
所以作为产品设计者，应该将关注点放在产品能否满足用户最高优先级的目标上。
这不禁让我想起了前段时间开源的据库文档管理平台 Databasir ，该平台有一个模板定制功能，用户可以将表头定义成自己想要的任意名字，如下图所示：
这个功能花费了我大量的时间做设计、研发，但它确实成为了一个实打实的垃圾功能：用户才懒得来定制呢！
主流用户关心的始终都是能看懂文档，而不是去学习如何定制文档好满足自己的偏好。
那么针对这个功能， Databasir 的主流用户实际要的是什么功能呢？其实是国际化。
对于一款开源产品来说，用户可能来自各个国家，在他们打开软件的时候，软件如果是以它系统的默认语言展示那就是最好的。
用户会期望更多的功能，通常是因为用户知道自己面临了什么问题，但却不一定知道最合适的解决方案，正如乔布斯先生所言
用户并不知道自己需要什么，直到我们拿出自己的产品，他们就发现，这是我要的东西&amp;hellip;&amp;hellip;
三类用户：主流、随意型、专家 一般在做产品之前我们都会定位产品面向的客户群，比如
软件编辑器的目标用户就是软件研发人员 ERP 软件的目标用户就是企业中的财务人员 运动品类垂直电商面向的就是喜欢运动或有健身倾向的用户 &amp;hellip; 在《简约至上：交互式设计四策略》中，作者又以用户对产品的态度将目标用户再次进行分类，主要有 3 种</description>
    </item>
    
    <item>
      <title>【Java】如何用 JDBC 写一个数据库文档生成工具？</title>
      <link>https://blog.cc1234.cc/posts/how-to-generate-doc-by-jdbc/</link>
      <pubDate>Tue, 19 Apr 2022 09:11:30 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/how-to-generate-doc-by-jdbc/</guid>
      <description>前言 在工作中经常会遇到需要交付数据库文档的场景，而编写这样的文档又是一个很枯燥、重复的事情，完全可以通过自动化的方式来完成这样的工作。
本文提供了一个在 JAVA 中如何基于 JDBC 来实现生成数据库文档的思路，希望对你有所帮助。
第一步：可行性？ JDBC 是 Java Database Connectivity 的缩写，从名字就能看出来是 Java 定义的连接数据库的一个标准，这个标准的具体体现就是一系列接口
java.sql.Connection java.sql.DatabaseMetaData java.sql.Driver java.sql.Statement javax.sql.DataSource &amp;hellip; 其中 java.sql.DatabaseMetaData （以下简称 DatabaseMetaData ）接口就是对数据库元信息的抽象，这里的元信息就包含了 schema、table、index、column 等我们熟知的概念。
通过 IDEA 我们可以很轻松的查看 DatabaseMetaData 接口定义的方法列表，比如
getTables：获取表信息 getColumns：获取列信息 getIndexInfo：获取索引信息 getPrimaryKeys：获取主键信息 &amp;hellip; 由此可见， 基于 JDBC 来生成数据库文档的可行性是没问题的，那么接下来我们就进入实验阶段。
第二步：Demo 实验环境：
Mysql Java Mysql 数据准备 CREATE DATABASE IF NOT EXISTS demo; CREATE TABLE demo.user ( id INT PRIMARY KEY AUTO_INCREMENT NOT NULL, username VARCHAR(255) NOT NULL, nickname VARCHAR(255) NOT NULL DEFAULT &amp;#39;&amp;#39;, create_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, CONSTRAINT uk_user_username UNIQUE (username) ) CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT &amp;#39;用户&amp;#39;; CREATE TABLE demo.</description>
    </item>
    
    <item>
      <title>也许是市面上最强的数据库文档管理工具了吧！</title>
      <link>https://blog.cc1234.cc/posts/databasir-show/</link>
      <pubDate>Thu, 24 Mar 2022 16:19:46 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/databasir-show/</guid>
      <description>背景 在软件行业，API 文档的自动化有着非常广泛而成熟的方案，但数据库模型文档的自动化却还是一片蓝海，我曾在网上搜寻良久，但并没有找到一款能同时满足我以下需求点的产品
自动化：基于数据库自动生成文档 版本化：文档历史版本回溯，版本差异对比 团队化：适应不同团队结构，多样性功能为跨团队协作赋能 个性化：给予使用者一定的文档定制能力 鉴于此，我利用业余的时间开发并开源了 这个项目，它专注于数据库文档的管理，核心能力就是上面提到的自动化、版本化、团队化和个性化四点。
如题，如果有更好的产品欢迎留言指出，给我一个奋斗的目标，当然这里也别忘点赞收藏一气呵成 ！
项目地址：https://github.com/vran-dev/databasir
文档地址：https://doc.databasir.com
问题 在进入正题之前，我想先聊一聊在数据库文档维护这个细分场景下，我们平时遇到的一些问题。
一、没有文档
这是最普遍的一个问题，没有人会否认文档对一个团队的价值，但文档的维护成本也经常让人望而却步
二、时间有限，这次就不写文档了
在人力、时间等资源都有限的情况下我们通常会暂时放弃文档的维护而优先完成业务目标（这本无可厚非），长此以往就会导致文档内容与业务模型之间的差异越来越大，即文档失真了。
三、百家齐放，格式标准不统一
每个人对文档的格式标准都有自己的想法，只是团队内部消化的话，大家的容忍度还是很高的，如果涉及跨团队协作的话，一个统一的格式标准能提高内容质量的最低下限。
四、失忆症，忘记补充文档
模型的变更 80% 的场景都是增量变化，比如加个字段、加一张表等，加了字段和表以后如果忘了更新文档就会造成前面提到的文档失真，但这非刻意为之，更类似于失忆症，根本原因与第二点不同。
现实中的问题远不止这些，但我们可以看看 Databasir 面对这些场景给出的答案，下面就进入 Show time 吧。
自动化，文档的事儿你不用操心 Databasir 基于 JDBC 实现了对数据库表、列、索引、外键等结构的解析，通过解析后的元数据再自动生成标准化的文档内容，从而替代了人工输出文档这种传统方式，节省人力的同时又降低了错误率。
目前 Databasir 生成的文档内容包含以下信息
表信息 列信息 索引信息 外键信息 触发器信息（仅 Mysql 支持） 文档页面的布局采用了经典的两栏布局，左侧显示所有的表信息，右侧显示文档的详细内容，如下图所示
到这儿还算不上自动化，只能算是半自动化，因为每次模型结构有变更的话还需要手动再同步一下，如果忘了同步就会造成前面提到的文档失真问题。
为了完全的自动化，Databasir 提供了定时自动同步机制，用户可以通过 cron 表达式设置同步时间。
下图展示了定时同步的配置页面
系统会根据配置的时间定时检查模型是否有变更，如果有变更的话就会更新并生成一个新的文档版本，并通过邮件的形式将变更内容通知到相关方。
除了标准的文档内容以外，Databasir 还支持 UML 格式文档生成，如果业务模型有使用到外键，那 UML 之间还能自动根据外键关系生成关联箭头。
版本化，内容变更一目了然 文档版本化可以让我们将文档轻松的回溯到任意指定存档点，在 Databasir 中版本号目前是一个递增的数字，数字越大代表版本越新。
在同步文档时检测到模型有变更才会创建新的版本号，这里的检测使用到了自研的 DIFF 引擎，目前支持以下内容的变更检测
数据库信息，比如版本号、产品切换 表信息，基于名称比对其他字段的变更，比如注释变更 列信息，基于名称比对其他字段的变更，比如类型变更，注释变更 索引信息，基于名称比对其他字段的变更，比如关联列变更 触发器信息，基于名称比对其他字段的变更 外键信息，基于名称比对其他字段的变更，比如关联列变更 下图展示了版本的切换功能</description>
    </item>
    
    <item>
      <title>再也不用手写模型文档了，Databasir beta 初体验</title>
      <link>https://blog.cc1234.cc/posts/databasir-beta-experience/</link>
      <pubDate>Fri, 11 Feb 2022 16:01:02 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/databasir-beta-experience/</guid>
      <description>背景 文档在软件开发流程中扮演着重要的角色，它用于描述软件的功能、设计，是软件能持续演进的重要组成部分，可是由于软件和文档各自都需要独立维护，这就经常导致软件已经迭代到了 C 版本，但是文档却还停留在 A 版本。
那有没有什么办法能让软件迭代更新的同时，文档也自动更新呢？
答案当然是肯定的，业界的 swagger、yapi 等工具，它们就可以基于软件当前的版本生成最新的 API 文档。
可惜除了 API 文档以外，程序员经常还需要写数据库模型文档，那么这一块有没有对应的工具可用呢？
screw 算是一个解决方案，不过它主要解决的是数据库模型文档生成的问题，在文档管理能力方面还属于空白状态，为了填补这一块空白，Databasir 就诞生了。
项目地址：https://github.com/vran-dev/databasir
简介 Databasir 旨在解决数据库文档的管理问题，主要包含以下功能
支持 mysql、postgresql 等常用数据库（理论拥有 JDBC 驱动的数据库都能支持） 自动或手动同步数据库 Schema 并生成文档 数据库历史版本文档查看 支持 markdown 等格式导出 扁平化的权限管理模式，团队管理、成员管理一应俱全 关注数据库安全，密码加密存储，并且不会再返回前端 &amp;hellip;&amp;hellip; 项目地址：
Github：https://github.com/vran-dev/databasir 项目预览：
安装 Databasir 规划了以下安装方式
Jar docker（TODO） docker compose（TODO) 目前 Jar 安装方式已经可用，而 Docker 和 Docker-Compose 的安装方式还在开发中。
接下来就演示一下通过 Jar 模式来部署 Databasir，更多细节也可以参考 Github 文档 。
通过 Jar 部署的话，对系统环境有一定要求，需要有以下依赖
Java11+ Mysql 系统环境就绪以后就可以前往项目 Release 页面（https://github.com/vran-dev/databasir/releases）下载最新版的 Databasir.jar。</description>
    </item>
    
    <item>
      <title>Java17 之 Pattern Matching 初探</title>
      <link>https://blog.cc1234.cc/posts/java-pattern-matching/</link>
      <pubDate>Mon, 18 Oct 2021 22:18:25 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/java-pattern-matching/</guid>
      <description>前言 前段时间 Java17 发布了，恰好在 Release note 中看到了 Pattern Matching 的信息，这极大的引起了我的兴趣，遂初步尝试了一番，以本文作为记录。
Pattern Matching 一般译作模式匹配，它其实并不是什么新的概念，C#、Scala、Hashkell 等其他语言在很早以前就支持了。
模式匹配里的模式指的不是设计模式，而是数据结构的模式，常见的有类型模式、结构模式、变量模式以及常量模式等。
回首过往 由于现在 Java 改进了迭代速度和发布周期， 采取了”小步快跑，快速迭代“的策略，所以像 Pattern Matching 这种大的改进也被拆分成了多个 Roadmap。
从 Java12 开始，Java 团队就在为引入 Pattern Matching 而努力了，他们不想做得跟 Scala 完全一样，而是希望有过之而无不及。
最开始的 Pattern Matching 是针对 instanceof 操作符的强化，光这项改进就经历了三个版本：从 Java14 开始，直到 Java16 后才 Release。
JEP 305 Pattern Matching for instanceof (Preview) JEP 375 Pattern Matching for instanceof (Second Preview) JEP 394 Pattern Matching for instanceof Java 团队认为 ”switch 语句就是一种完美的模式匹配“，所以它们也为 switch 语句作了改进，该功能已经在 Java14 中 Release</description>
    </item>
    
    <item>
      <title>纵享丝滑，Mybatis Generator 代码持续生成实践</title>
      <link>https://blog.cc1234.cc/posts/mybatis-and-generator/</link>
      <pubDate>Thu, 09 Sep 2021 21:41:39 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/mybatis-and-generator/</guid>
      <description>前言 Mybatis Generator 是与 Mybatis 配套的代码生成工具，它可以基于 Database 的元数据自动生成实体、Java Mapper 以及 XML 等 Boilerplate code。
但目前很多实践都只是在项目初期使用该工具，后面由于文件冲突、功能扩展等原因都不会再使用它生成代码，这种不可持续性让 Mybatis Generator 的价值大打折扣。
本文则分享了我的一些实践和尝试，让 Mybatis Generator 的代码生成在项目的全生命周期内得以持续，希望能为你带来一些灵感。
项目源码请通过 Github 查看。
目标 我期望的是只要每次数据库有变动都可以使用 Mybatis Generator 来生成代码，而不仅仅是项目首次初始化使用。要实现这样的目标就得解决代码重复生成时可能引入冲突，生成的代码功能不满足需求等问题。
也就是说项目得有以下几个特性
隔离：自动生成的代码能够以某种形式与手写的代码隔离 扩展性：用户不需要（也不允许）去修改生成的代码 可以修改代码生成的规则，比如通过修改配置或扩展代码生成工具等 能够以某种非侵入性的方式去扩展生成的代码的功能 一致性：生成的代码结构只和项目有关，而不会受系统环境、构建工具等外部依赖的影响 接下来就正式开始尝试把
集成 Gradle 由于 Mybatis Generator 官方没有提供 Gradle Plugin，所以我选择了通过社区开源的 Gradle 插件 Mybatis Generator Plugin 来集成。
集成方式很简单，首先需要在 build.gradle 中引入一下插件，并配置指定的版本
plugins { id &amp;#34;com.thinkimi.gradle.MybatisGenerator&amp;#34; version &amp;#34;2.3&amp;#34; } 刷新完 Gradle 以后，我们就可以在 build.gradle 中通过 mybatisGenerator 块来配置运行时依赖的 JDBC 驱动、mybatis-generator-core 的版本以及代码生成的规则文件</description>
    </item>
    
    <item>
      <title>纵享丝滑，Mybatis-Dynamic-Sql 集成体验</title>
      <link>https://blog.cc1234.cc/posts/mybats-dynamic-sql-integration/</link>
      <pubDate>Thu, 02 Sep 2021 22:20:44 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/mybats-dynamic-sql-integration/</guid>
      <description>前言 我大概两三年没有使用过 Mybatis 了，最近因为项目的原因重新开始使用 Mybatis，体验上总感觉不丝滑，即使加了 Mybatis plus 也没有达到我心中的预期。
回想这几年用的 JOOQ，直接用 Java 写 SQL 的体验太棒了。它实现的 DSL 完备度很高，几乎和写原生的 SQL 体验差不多了。
那 mybatis 生态有没有类似于这样的框架呢？还真巧了，官方还真就有一个叫 Mybatis-dynamic-SQL 项目。而本文是记录我在集成 Mybatis dynamic SQL、Mybatis Generator 时的一些历程。
整个项目我已经放在 Github （Mybatis-Dynamic-SQL-integration-demo） ，如果你感兴趣可以点个 star，我会持续更新。
观察维度 在开始实际写代码体验之前，我列了四个维度来观察框架是否能符合自己的期望，它们分别是
Mybatis 生态兼容性 代码生成能力 无 XML DSL 完备度 下面一个一个来过一下
一、Mybatis 生态兼容性
就是要和 Mybatis 既有的生态保持兼容性，比如一些 SQL 日志插件、分页查询插件以及通用的 TypeHandler，二级缓存等
二、代码生成能力
数据库实体可以自动生成，开发者不需要（通常也不允许）修改这一部分自动生成的代码，但开发者可以通过配置项来灵活的制定生成规则以便扩展。
要是代码生成工具能和构建工具（比如 Maven、Gradle）无缝集成那就更好。
三、无 XML
零 XML
四、DSL 完备度（Domain Special Language）
既然是用 Java 的方式来写 SQL，那框架就得对常用的 SQL 有完善的支持，对不常用的 SQL 也能有相应的解决方案。</description>
    </item>
    
    <item>
      <title>我的心动生产力 — Anne Pro2 机械键盘体验</title>
      <link>https://blog.cc1234.cc/posts/keyboard-anne-pro2/</link>
      <pubDate>Wed, 01 Sep 2021 18:44:35 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/keyboard-anne-pro2/</guid>
      <description>前言 这些年入手了不少的外设，机械键盘也尝试了 104 键、96 键、87键等布局，但一直没敢去入手更小的 60% 的键盘，因为这个布局我一直没有遇到符合我想象的产品。
直到我发现了 Anne Pro2 以后，才发现“梦中情人”原来离我这么近，它几乎符合我对 60% 键盘的所有想象
蓝牙、Typec 有线双模连接 自定义功能强大，创新的 Magic FN、Tap 功能 简约的设计、灯光可自定义 心动加行动，人生中的第一款 60% 布局的键盘 Anne Pro2 就入手了&amp;hellip;&amp;hellip;
本文我会简单的过一下参数、手感和灯光，内容的更多篇幅我会花在分享它的一些键位功能的定制化方面上。
颜值 官方原厂的键帽是白色透光的，颜值非常的素雅
我到手后换了一套 SA 的键帽，感觉没了原厂那种仙气，也不知是不是我拍照的问题
参数 先来看一下官方给出的一些参数吧、不在意的可以直接跳过
名称 参数 键盘名称 Anne Pro2 有线连接 TypeC 无线连接 蓝牙 5.0 键盘体积 97 * 284 * 49mm 键盘净重 635 ± 50g 电池容量 1900mAh 光源类型 LED 贴片 RGB 灯珠 键帽材质 PBT 双色注塑键帽 外壳材质 ABS 手感 这把键盘我是想当作主力办工键盘来使用的，考虑到静音和手指疲劳等因素，我最终是选择了佳达隆的 CAP 红轴。</description>
    </item>
    
    <item>
      <title>分享：对积分业务的一些思考</title>
      <link>https://blog.cc1234.cc/posts/points-system-1/</link>
      <pubDate>Tue, 29 Jun 2021 21:09:26 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/points-system-1/</guid>
      <description>前言 最近一直在做和积分相关的业务系统，趁着这段时间有空就把最近对于积分的一些思考总结下来做个分享，仅供参考。
下面是本文的大纲
什么是积分 为什么要做积分 积分的入口和出口 积分的货币属性 积分的关键数 如果有相关错误和意见，欢迎指出
什么是积分？ 在用户运营中，拉新、促活、转化等是绝对不会缺席的话题，要实现这些目标有很多的方式，而积分正式其中之一。
在我们现在的生活中，积分可以说是随处可见了，比如
移动运营商积分 电商购物平台积分 还有诸如信用卡积分、酒店积分等等，数不胜数。
积分本质上就是平台发放的一种虚拟货币，平台可以基于积分设计很多价值交换的功能，比如
积分兑换实物 积分兑换虚拟物品 积分抵扣现金支付 &amp;hellip;&amp;hellip; 从平台自身的角度来看，积分其实是一种让利行为，即平台将自己的利润划一部分出来以积分的形式反馈给客户。
当把积分给到用户时，平台就产生了一笔债务，当用户消耗一笔积分以后，平台就偿还了一笔债务。
为什么要做积分？ 据统计数据显示：商家发展一名新用户的成本是挽留老用户的 3 ~ 10 倍，向新顾客推销产品的成功率只有 15%，而向现有忠诚顾客推销产品的成功率则高达 50%。
而积分体系可以很好的连接用户与产品，维持用户，建立长期的需求，从而将新用户培养成高价值用户
一般这种用户关系的维护都称之为客户忠诚度计划，积分只是其中的体系之一
从哪里来？到哪里去？ 哲学上有三个终极问题：我是谁？我从哪里来？要到哪里去？
换到本文谈到的积分里就是：积分是什么？积分从哪里来？积分到哪里去？
是什么前面已经谈过了，本节着重讨论一下后面两个问题
积分从哪里来？也可以理解为获取积分的入口，一般常见的有
消费返积分 参加活动返积分 签到 分享 &amp;hellip;&amp;hellip; 到哪里去实际上就是指如何消耗掉积分，也就是常说的积分出口。
如果只有入口，没有出口的话，那用户就感受不到积分的价值，我们想通过积分体系与用户建立长期关系的目标也就落空了。
常见的出口有
积分兑换（实物 or 虚拟商品） 积分抵现 / 提现 积分过期自动作废 &amp;hellip;&amp;hellip; 这样用户、入口、出口就形成了积分体系的价值闭环
这里深入讨论一个细节点：为什么积分需要有有效期并作废？
前面提到过积分对于平台来说其实是成本，也可以认为是一种债务，如果债务一直累积得不到释放会引起多种连锁反应，比如
信用贬值：用户信任感缺失，丧失获取积分的动力 积分贬值：平台为了加速积分的消耗，同一商品的积分定价会越来越高 挤兑风暴：每次平台上新，都会发生挤兑，因为人均持有积分数累积太多 而过期是一种可以低成本的消耗累积积分的一种方式
而且积分的过期会给用户带来一种缺失感，从而促进用户对积分价值的认知，达成基于积分与用户建立长期关系的目标。
积分的货币属性 前面有说到积分是一种让利行为：平台将自己的一部利润划分出来以积分的形式返给用户。
这就说明积分天然就有一定的货币属性，只不过它的价值被局限在了平台内部（目前也有一种联合积分的模式，它的积分可以跨平台使用）。
在积分建立之初就应该定义好汇率
汇率：指的是两种货币之间兑换的比率
有了汇率这样的概念后，就能够基于此去核算成本，更好的计算 ROI （投入产出比）了。
积分关键数据 数据可以直观的为我们展示当下整个积分生态的健康指数，下面简单列了一些（基本的 PV、UV 就列了）</description>
    </item>
    
    <item>
      <title>一介小白的开源随笔</title>
      <link>https://blog.cc1234.cc/posts/essay-about-my-open-source/</link>
      <pubDate>Wed, 26 May 2021 21:47:01 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/essay-about-my-open-source/</guid>
      <description>[埃里克·雷蒙] 在其著作《大教堂和市集》里面探讨黑客社区与自由软件原则， 这可以算做是开源文化的启蒙。
时至今日已过去 20 多年了，虽然开源的定义在不断的演化，但是自由和社区仍然是它的基因。
我忘了我接触开源有多久了（两三年？亦或三四年？），但我认真的发起和参与却是最近一年，这段经历让我对开源产生了不同的认知，甚至也改变了我对软件研发的一些认知。
难得矫情一次，就做一个随笔，写写自己在开源路上的一些心路历程。
如果你想了解我的开源项目，可以通过最后附录中的 PrettyZoo 链接跳转
开源与梦想 我只知道刚接触开源的时候，就被这种文化给深深的吸引着，也许人的天性就向往自由吧。
看着那些知名开源项目的主页，幻想着自己也是某个上千 star 项目的 owner，Github 的主页打开就是 lü 油油的一大片。
对，就像下面这样
那时候也还年轻，愿意为此做出尝试和努力，断断续续的参与了一些知名开源项目的边边角角，不过最终还是没有坚持下去。
再后来就逐渐遗忘了这件事情，在时间面前，它终是蒙上了一秒又一秒的尘&amp;hellip;&amp;hellip;
要不是突然的一阵风吹开了这已被尘封的梦想，我大概也不知道我竟然也成了曾经梦想成为的样子：一个上千 star 项目的 owner , github 主页是 lü 油油的一大片
All good things come to those who wait
开源与开源 开源既可以只是开放源代码，也可以不止是开放源代码，而这两个解读也恰好是我做开源经历的两个阶段。
最开始我也是把项目的源码放在 github 上就不管了，这就像把商品放在一个公共陈列柜里一样，不管有人看或不看，用或不用，我自佛系。
后来我逐渐理解到开源其实可以不止是开放源代码，开始尝试以更多的角色去做开源
作为项目研发：去解决 bug，开发新的功能，技术可行性调查，系统架构设计等 作为项目运营：去写文档，处理社区 issue，去各个平台做推广，关注反馈等 作为项目 owner ： 去挖掘用户需求，思考交互设计，绘制功能原型，规划迭代等 &amp;hellip;&amp;hellip; 这样一种对开源的认知改变带来的变化非常直观的体现在了项目的各项数据上，比如 star 数， 最开始一年都是不温不火，后面就开始有了明显的增长
社区的 issue 数量也有着类似的增长曲线
这种感觉就像自己开始创业了，但整个公司就我一人，包揽全职。
开源与生活 在有限的时间面前，投入在开源上多一分钟，那么生活就会被压缩一分钟。
但是当我认真的想在这两者画一条分界线的时候却又做不到，因为做开源其实算是自己选择的一种生活方式，两者并不是泾渭分明的。
最疯狂的一段时间我基本下班后就在做开源相关的事情，也包括很多个周末
后来我开始小心翼翼的进行克制，我得把时间再慢慢分配一些在看书、旅游、玩游戏、工作等其他事情上去。
时间越发的有限，那我只能尽可能的想办法去提高单位时间所带来的价值，去尝试
实践 MVP（最简化可实行产品），保证我的原型就是我已经满意的样子了再去写代码 追求自动化，减少重复的工作 重视系统设计，保证系统的演进成本足够低 重视工程管理，尽量减少核心功能之外带来的熵 &amp;hellip;&amp;hellip; 事实证明这是非常有效的，也让自己养成了一些良好的习惯。</description>
    </item>
    
    <item>
      <title> 金三银四，工程师简历不要这么写 </title>
      <link>https://blog.cc1234.cc/posts/interview-experience/</link>
      <pubDate>Fri, 26 Feb 2021 11:22:32 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/interview-experience/</guid>
      <description>0x00 古语有云：凡事豫（预）则立，不豫（预）则废。
对于跳槽来说也是一样的，就算是金三银四黄金季，如果没有好好的准备也可能会折戟沉沙。
而跳槽首先要准备的自然就是简历，一份好的简历能极大的提高面试邀请率和通过率，使得求职之路事半功倍。
而本文就分享一下写出一份好的简历应该避免的三个误区
细节太多
重点太多
内容太多
PS：由于我自己的职业关系，分享的内容会更偏向于软件工程师一些
0x01 细节太多 作为工程师，在简历中我们经常会用一小节内容来描述自己的技能列表（也叫技术栈），就像下面这样
## 技术栈 1. 熟悉 Java、JavaScript、c、ruby 等语言的字母拼写 2. 熟悉电脑开机、关机等操作 3. ...... 而在描述这一节内容时出于以下目的我们往往会过多的添加很多细节性的描述
提高简历与企业的 JD （Job Description）匹配度 展现自己的技能深度和广度 在好几年前，我就这么干过
## 技术栈 1. 熟悉 Java、Scala 编程，掌握 OOP 思想，深入研究过 JDK 下部分模块的源码（集合库，并 发库）; 2. 对 Spring 框架部分模块（MVC, IOC, AOP）源码有深入研究，能对其进行一些扩 展定制， 并对其设计有一定的见解 ; 3. 熟悉 Mybatis, Dubbo 等框架，并对其部分源码和设计有一定的阅读研究，能进行 一些简单的扩展定制 ; 4. 对 JVM 有一定的了解，包括常见的一些调优参数，致力于写出 GC 友好的代码 ; 5. 熟悉常见的设计模式和设计原则，能恰当运用， 追求极简设计 ; 6. 掌握 mysql，redis, memcached, zookeeper 等常见的中间件的使用 ; 7.</description>
    </item>
    
    <item>
      <title>推荐一款颜值与功能双在线的 Zookeeper 可视化工具</title>
      <link>https://blog.cc1234.cc/posts/prettyzoo-tutorials/</link>
      <pubDate>Wed, 24 Feb 2021 15:50:43 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/prettyzoo-tutorials/</guid>
      <description>前言 虽然市面上 Zookeeper 的 WEB 管理工具很丰富，但是却很难找到一款满意的图形化客户端。
鉴于这样的情况，我就自己开发了一款用于管理 Zookeeper 的图形化工具，取名 PrettyZoo，意为：Pretty nice Zookeeper GUI。
PrettyZoo 是一个基于 JavaFX 和 Apache Curator 实现的 Zookeeper 图形化工具，该项目完全开源，可以通过 Github 主页查看。
它拥有众多个性化的功能，比如
支持 Mac / WIndows / Linux 多平台 支持 SSH-Tunnel 连接 节点 CRUD （增删改查） 节点数据 pretty format，目前支持 JSON、XML 支持命令行操作（80% 的命令都支持了） 支持 4-letter command &amp;hellip;&amp;hellip; 下面多图预警
安装 得益于 Java 的跨平台特性， PrettyZoo 天然就支持 Windows / Mac / Linux 等多平台，再加上使用了 Jigsaw（模块化） 和 JPackage 等众多新特性，用户无需再独立安装 JRE 即可运行。
安装包的下载地址（可能需要梯子）, 记得选择系统匹配的安装包
Windows：prettyZoo-win.msi Mac: prettyZoo-mac.</description>
    </item>
    
    <item>
      <title>  你知道 Java 的偏向锁要被废弃掉了吗？ </title>
      <link>https://blog.cc1234.cc/posts/java-biased-locking/</link>
      <pubDate>Mon, 01 Feb 2021 23:45:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/java-biased-locking/</guid>
      <description>前言 偏向锁是从 JDK1.6 引入的一种针对 synchronized 的锁优化技术，然而从 JDK 15 开始，这一特性被官方标记为废弃状态，如果还想继续使用的话需要通过 JVM 参数手动启用。
-XX:+UseBiasedLocking 那么问题来了，JDK15 为什么要废弃偏向锁呢？
什么是偏向锁？ 在回答 Why 之前要先明白 What：什么是偏向锁？
在 Java 中可以使用 synchronized 来保证代码块同一时间只被一个线程访问（互斥），它是基于 Monitor Object 模式来实现的。
int i; public synchronized void mutex() { i++; } public void mutext2() { synchronized(this) { i++; } } 当线程请求进入临界区时都需要先获取一个 monitor 对象（类似于准入许可证），获取 monitor 对象是通过 compare-and-swap (CAS) 操作来实现的。
从 CPU 的角度来看，CAS 其实是一个开销很昂贵的操作，有没有什么方法可以避免呢？
我们先看一个 JAVA 团队观察到的现象：
在大多数对象的生命周期内，基本上只会有一个线程访问临界区
基于此可以得出一个优化方案：当某个线程首次访问临界区时记录下该线程的信息，当再有线程访问该临界区时判断是否是首次访问的线程
如果是：就直接放行，这样就避免了通过 CAS 获取 monitor 的操作 如果不是：就升级为轻量级锁 这个优化方案其实就是偏向锁了，在 JVM 的实际实现中，锁升级其实有 4 个状态，并且是只可升级不可降级。</description>
    </item>
    
    <item>
      <title>我是如何开发了一款‘有人用’的开源软件</title>
      <link>https://blog.cc1234.cc/posts/how-to-develop-prettyzoo/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/how-to-develop-prettyzoo/</guid>
      <description>背景 PrettyZoo 是在去年国庆（2019 年）时开发的一个用于管理 Zookeeper 的桌面图形化工具，当时是因为在学习 Elastic-Job-Lite 框架的源码时涉及到了 Zookeeper，想着借助图形化工具去更直观的了解整个框架的设计，但在市面上却找不到一款符合自己期望的产品，那就只能自己动手丰衣足食了，这算是 PrettyZoo 诞生的初衷了。
其实我已经写过一篇文章来简单介绍过这个产品的研发历程（从 Java8 到 Java11 ： PrettyZoo 开发回顾（模块化在 GUI 中的实践））, 不过那篇文章主要侧重于产品的技术演进过程，这一篇文章是基于国庆重构后的全新版本来写的，记录了自己在这个重构的过程中各个阶段所做的事情，主要包括以下内容
需求分析 原型设计 技术选型 架构设计 成品展示 需求分析 上一节的背景描述了我为什么要开发这样一款软件，而这一节的主要内容则是分析我想要开发的软件应该有的功能点。
该产品是用于管理 Zookeeper 数据，那么需求其实也需要围绕着 Zookeeper 的功能来分析，这就像为人作肖像画一样，得先去分析目标的特性。
我将分析后的需求整理成了下面的一个表格，并对功能的优先级、必要性做了标注
需求 优先级 是否必须 连接创建 高 √ 连接删除 高 √ 节点展示 高 √ 节点创建 高 √ 节点删除 高 √ 节点数据更新 高 √ 递归操作支持 中 √ 节点数据格式化（JSON、YAML） 低 × SSH Tunnel 支持 中 × ACL 支持 中 √ 配置导入/导出 中 × 当然实际的产品开发中还会去调查类同类产品，去参考它们的功能、设计等， 这方面我就略过了。</description>
    </item>
    
    <item>
      <title> Scala 与 Algebraic data type</title>
      <link>https://blog.cc1234.cc/posts/scala-adt/</link>
      <pubDate>Tue, 18 Aug 2020 20:50:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/scala-adt/</guid>
      <description>前言 在计算机编程中，数据类型（Data type）是一个基本概念，它是数据的一个属性，编译器或解释器可以根据该属性知道开发者打算如何使用该数据。
常见的数据类型有基本数据类型（Primitive data types）和组合数据类型（Composite Types）。
基本数据类型一般都是由编程语言内置的，比如 Integer、Float、Boolean、Char 等，而组合数据类型是从基本类型派生出来的，一个组合类型可以由基本类型组成，也可以由「其他组合类型 + 基本类型」组成。
比如在 Java 中通过 class 关键字就可以创建一个组合类型
public class User { private String name; // 姓名 private Integer age; // 年龄 private List&amp;lt;User&amp;gt; familyMembers; // 家庭成员 } Scala 中的 case class 也是组合类型
case class User(name: String, age: Integer, familyMembers: List[User]) 组合类型又可以分为很多种，而本文要聊的 Algebraic data type （以下简称 ADT 或 ADTs）就是其中之一
注：Algebraic data type，一般译作代数数据类型
Algebraic data type Algebraic data type 在函数式编程语言中是一个很常见的概念，要理解 ADT ，得先明白 Algebra（代数）的含义。</description>
    </item>
    
    <item>
      <title> Scala2 如何实现 Type class 派生</title>
      <link>https://blog.cc1234.cc/posts/typeclasses-deriving/</link>
      <pubDate>Sat, 15 Aug 2020 00:04:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/typeclasses-deriving/</guid>
      <description>前言 本文主要是讨论在 Scala 中自动为 case class 派生 Type class 实例，如果你不知道什么是 Type class 的话，建议先阅读我的上一篇文章 《真的学不动了： 除了 class , 也该了解 Type classes 了》。
本文使用的 Scala 版本为 2.13.2，Shapless 版本为 2.3.3
提出问题 假设我现在有一个用于生成随机测试数据的 Type class，并且已经实现了 Int， Boolean 等基本类型的 Random 实例
trait Random[T] { def random(): T } object Random { def apply[T]()(implicit random: Random[T]) = random.random() implicit val intRandom = new Random[Int] { override def random(): Int = Math.abs(scala.util.Random.nextInt(10000000)) } implicit val stringRandom = new Random[String] { override def random(): String = UUID.</description>
    </item>
    
    <item>
      <title> VAVR：颠覆你的 Java 体验 </title>
      <link>https://blog.cc1234.cc/posts/vavr-1/</link>
      <pubDate>Sat, 25 Jul 2020 09:50:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/vavr-1/</guid>
      <description>何方神圣？ 众所周知， Java8 在一定程度上支持了函数式编程，但标准库提供的函数式 API 不是很完备和友好。
为了更好的进行函数式编程，我们就不得不借助于第三方库，而 VAVR 就是这方面的佼佼者，它可以有效减少代码量并提高代码质量。
VAVR 可不是默默无闻之辈，它的前身是发布于 2014 年的 Javaslang，目前在 github 上有着近 4k 的 star。
看到这儿，很多人就说我标题党了，一个 Java 库还来颠覆 Java ？
这可不不是我玩震惊体，打开 VAVR 的官网 ，它的首页就用加粗字体写着 「vavr - turns java™ upside down」
这翻译过来不就是颠覆 Java 吗？
食用指南 阅读本文需要读者对 Java8 的 lambda 语法和常用 API 有一定的了解。
由于是一篇框架的介绍文（地推 ing），为了避免写成官方文档的翻译，本文会有一些约束
不会穷尽所有特性和 API，仅做抛砖引玉 不会深入到源码细节 关于示例代码，基本会以单元测试的形式给出并保证运行通过
注：本文使用的 VAVR 版本为 0.10.3，JDK 版本为 11。
先来个概览
集合，全新的开始 不得不说 Java8 的集合库引入 Stream 以后确实很好用，但也正是因为使用了 Stream，不得不写很多样板代码，反而降低了不少体验。
// of 方法是 Java9 开始提供的静态工厂 java.</description>
    </item>
    
    <item>
      <title>真的学不动了：Scala3 与 Type classes</title>
      <link>https://blog.cc1234.cc/posts/typeclasses-2/</link>
      <pubDate>Sun, 19 Jul 2020 10:45:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/typeclasses-2/</guid>
      <description>引言 Type classes 源自 Haskell，在 Scala 中并没有直接的语法和概念，但却可以借助于强大的隐式系统间接实现，一般称之为 Type classes Pattern。
Type classes pattern 可谓是 Scala 中的屠龙技之一，然而这一招式随着 Scala3 的发布也产生了巨大的变化&amp;hellip;&amp;hellip;
关于 Type classes 更多内容，可以参考 《真的学不动了: 除了 class , 也该了解 Type classes 了》。
回顾 Scala2 与 Type classes Scala2 中 Type classes Pattern 有个固定的套路
基于 trait 和泛型定义 Type class 实现 Type class 实例 定义包含隐式参数的函数 下面用 Scala2 中的 Type classes Pattern 来改造一下经典的 Comparator 接口，相比于上一篇文章，这里的实现会多一些细节。
trait Comparator[T] { def compare(a: T, b: T): Int } object ComparatorInstances { implicit val intComparator = new Comparator[Int] { override def compare(a: Int, b: Int) = a.</description>
    </item>
    
    <item>
      <title>真的学不动了：除了 class , 也该了解 Type classes 了</title>
      <link>https://blog.cc1234.cc/posts/typeclasses-1/</link>
      <pubDate>Wed, 15 Jul 2020 18:45:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/typeclasses-1/</guid>
      <description>前言 作为一个 Java 开发者， class 的概念肯定是耳熟能详了，可是在山的另一边还有拥有别样风情的 type classes，但不翻过 Java 这座山，它就始终隔着一层纱。
一个经典的问题 在编程中，经常需要判断两个值是否相等，这就是判等问题， 然而在很长的一段时间内这个问题都没有一个标准的解决方案。
我这里统一使用 “值” 来代替对象、基本类型等等概念，以便于简化沟通
在 Java 中，我们可以用 == ，也可以用 equals 来判断值是否相等
public void test() { boolean res = &amp;#34;hello&amp;#34; == &amp;#34;world&amp;#34;; boolean res2 = &amp;#34;hello&amp;#34;.equals(&amp;#34;hello&amp;#34;); boolean res3 = 3 == 3; boolean res4 = 5 == 9; } 熟悉 Java 的同学都知道对于非基础类型， equals 方法的默认实现其实就是调用 == 操作符，而 == 操作比较的是对象的引用地址
public class Object { // ...... public boolean equals(Object obj) { return (this == obj); } // .</description>
    </item>
    
    <item>
      <title>多态都不知道，谈什么对象</title>
      <link>https://blog.cc1234.cc/posts/polymorphism/</link>
      <pubDate>Wed, 27 May 2020 23:40:26 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/polymorphism/</guid>
      <description>前言 封装、继承、多态作为 OOP 世界的老三样，几乎是必背的关键词。
而在刚学习 Java 的很长一段时间，我对多态的理解一直处理很迷糊的状态，重载是多态吗？泛型是多态吗？继承关系是多态吗？
实际上都是，无论重载、泛型，还是继承关系都是多态的一个具体体现，也被归属为不同的多态分类
Ad hoc polymorphism（特定多态，也译作特设多态） Parametric polymorphism（参数化多态） Subtyping（子类型多态） 当然不止上面三种分类，像 Scala 就还有另外一种多态分类
Row polymorphism（行多态） 别被这些名词概念唬住，下面我们就通过代码实例来一一过一遍。
Ad hoc polymorphism（特定多态） 特定多态是由 Christopher Strachey 在 1967 年提出来的，从它的取名我们可以大概猜到，它是针对于特定问题的多态方案，比如：
函数重载 操作符重载 函数重载指的是多个函数拥有相同的名称，但却拥有不同的实现。
比如下面的函数重载示例，展示了两个名为 print 的 函数，一个打印字符串，一个打印图像。
public void print(String word) { ... } public void print(Image image) { ... } 操作符重载本质上是一个语法糖，实际的体验与函数重载相似，以 Java 中的 + 操作符为例：
实际上 Java 的 + 不完全算是操作符重载，因为它针对于字符串的操作其实是将 + 转译成了 StringBuilder 来处理的，算是语法糖。
但仍可以借助于它来理解操作符重载
1 + 1 1 + 1.</description>
    </item>
    
    <item>
      <title>一次微服务重构总结 </title>
      <link>https://blog.cc1234.cc/posts/xingren-wx-service-refactor/</link>
      <pubDate>Sun, 10 May 2020 23:48:05 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/xingren-wx-service-refactor/</guid>
      <description>一次微服务的技术重构总结 为什么要重构 前段时间接手了一个新的服务，该服务的主要职责是封装「微信公众号」相关的 API ，然后提供整合后的能力给其他业务使用，算是一个很基础的服务。
该服务诞生已有些年头，陆陆续续的功能叠加使得该服务的设计已经背离了初衷，就像下图一样，虽然在努力奔跑着，但早已不堪重负&amp;hellip;&amp;hellip;
那么是时候重构了，引用一下《重构：改善既有代码的设计》中对重构做的事情的描述
重构很像是在整理代码，你所做的就是让所有东西回到应处的位置上。
代码结构的流失是累积性的。越难看出代码所代表的设计意图，就越难保护其中设计，于是该设计就腐败得越快。
再划分层 该服务采用的是传统分层架构，分 3 层 共 4 个组件
Controller：提供 restful API Service：业务核心逻辑 Model：负责与 DB 交互 WX-API: 代理微信的 API 调用 然而在软件的演化中，几个组件的边界却渐渐变得模糊，有融合的趋势
为了指导后续的重构，第一步就是重新划分分层（其实就是还原最开始的设计），当然这里的分层指的是技术分层。
下图就是理想中的分层设计
组件依赖方向是自上而下对的单向依赖，为什么会将第三方服务 WX-API 放在底层呢？
这很好理解，应为要重构的服务就是基于微信提供的能力构建的。
组件模型独立 共享模型对象是造成各个组件耦合的原因之一，那么什么是共享模型对象呢？
WX-API 与微信官方 API 交互时有一套模型对象，Controller 与其他服务交互时也有一套模型对象，如果这两套模型对象实则是复用的同一套，那么这就是共享模型对象。
这里看似复用，实则违背了单一职责，因为从变化的根本原因来说，两者是截然不同的
WX-API 的变更原因主要和微信官方 API 的升级有关 Controller 的变更原因主要和其他服务或业务的需求相关 这就会导致共享的对象模型会因为不同的原因而产生变化，而这样的变化可能对某个组件产生破坏性的影响，抑或是使得两个组件的耦合性越来越强。
所以就必须得将组件的模型独立出来，不同的模型需要进行转换（Convert)
可以看出 Controller 和 Service 仍然共享了一套模型，这是一种权衡下的抉择，因为过于独立的模型会提高维护的成本。
代码坏味道 代码坏味道指的是任何可能导致深层次问题的代码，这也是重构需要解决的问题。
循环依赖 正常情况下，分层架构并没有限制同层内的依赖关系，但在严格分层模式下，同层内的依赖是被禁止的，这样可以有效的避免循环依赖。
而在该服务中，在 Service 组件内部由于继承的设计而隐式的带来了不少循环依赖，
解决循环依赖的思路很简单，只需要在循环依赖链路中取消一条依赖关系即可。
而具体的方案就有很多种了，这里提一下我的解决方案：加一层中间类，采用组合替代继承。
如下图所示，抽取 BaseService 和 ThirdService 共同依赖的行为到 MiddleHandler，然后两者共同依赖 MiddleHandler，再观察整个依赖图，没有循环链路了。</description>
    </item>
    
    <item>
      <title>Spring Ant-Style Matcher 笔记</title>
      <link>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</link>
      <pubDate>Mon, 04 May 2020 11:40:46 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/spring-ant-matcher-note/</guid>
      <description>在使用 Spring 的时候经常会写路径相关的配置，比如
@RequestMapping 中配置请求路径 @ComponentScan 中配置包路径 为 Interceptor 配置规则 &amp;hellip;&amp;hellip; 而这些路径的配置规则中，我们经常会看见 、* 等类似于正则表达式的符号，这实际上就是 Spring 的路径匹配规则。
Spring 默认有一个 AntPathMatcher 类用于处理这类路径的规则匹配， 它借鉴了 Ant 的实现（如果你感兴趣的话，可以在点击这里进行了解），这也是为什么称之为 Ant-Style 的原因。
题外话：Ant 是一个自动化构建工具，最开始是为了解决 Tomcat 的构建问题而诞生的
Ant 本身是定义了三种匹配规则，而 spring 在此基础之上额外扩展了一种，参考下面的表格
? 匹配单个字符 * 匹配 0 个或多个字符 ** 匹配 0 个或多个目录 {spring: [a-z]+} 匹配正则表达式 [a-z]+, 将匹配后的路径作为 spring 的变量 下面的表格展示了一个具体的实例
com/t?st.jsp 匹配 com/test.jsp，com/tast.jsp，com/txst.jsp com/*.jsp 匹配 com 目录下所有以 .jsp 结尾的文件 com/**/test.jsp 匹配 com 所有层级的子目录下的 test.jsp 文件 org/springframework/**/*.jsp 匹配所有 org/springframework 的子目录下的 jsp 文件 com/{filename:\w+}.</description>
    </item>
    
    <item>
      <title>HashMap 的细节笔记</title>
      <link>https://blog.cc1234.cc/posts/hashmap-some-detail/</link>
      <pubDate>Mon, 27 Apr 2020 21:19:45 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/hashmap-some-detail/</guid>
      <description>HashMap 的节点转为红黑树以后，树形节点之间是基于什么来比较的呢？ 首先会根据 key 的 Hash 值来进行比较，如果相等的话，会再判断 key 是否实现了 Comparable 接口，如果是的话，可以直接通过 compareTo 方法进行比较。
如果 hash 值相等，而且也没有实现Comparable 接口呢？此时会对 key 对象使用 System.identityHashCode(key) 进行再次 hash 运算，最后再根据新的 hash 值进行比较。
那么 System.identityHashCode 又是什么操作呢？
这是一个 native 的方法，实现的原理也很简单，就是不管你对象有没重写 hashCode 函数，它都只返回对象默认的 hashCode 值。
为什么 HashMap 的链表节点冲突数达到 8 才会转为红黑树？ 在 hashmap 的源码注释中有一段 Implementation notes， 里面有提到具体的决策原因。
虽然红黑树的查询事件复杂度是 logN, 但是红黑树节点的 size 大概是普通节点的 2 倍，而且在插入效率方面，红黑树的插入时间复杂度为 logN, 链表的插入节点时间复杂度是 O (1)。
综上所述，实则是一个时间和空间的决策，那么为什么是 8 呢？
如果 key 的 hash 值分布的足够均匀，几乎不会转换成树形节点。
假设使用随机的 hash 算法，理想情况下，通过泊松分布的概率函数可以计算某个桶位冲突节点达到 K 个的概率，设 λ = 0.</description>
    </item>
    
    <item>
      <title>从 Java8 到 Java11 ： PrettyZoo 开发回顾（模块化在 GUI 中的实践）</title>
      <link>https://blog.cc1234.cc/posts/java-gui-experience/</link>
      <pubDate>Sun, 12 Apr 2020 12:30:37 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/java-gui-experience/</guid>
      <description>起因 elastic-job-lite 是公司使用的一款定时任务调度框架，该框架将所有的任务调度信息都注册进了 zookeeper 中。
为了方便定位相关的问题，我去网上搜了 zookeeper 相关的图形化客户端，结果没有一款符合自己的需求，于是就干脆自己写一个算了。
该客户端是去年国庆假期写的，经历了从 Java8 到 Java11 的重构（主要是模块化），该文章主要是对整个过程的一个回顾
从需求分析到实现 面向用户：zookeeper 用户
软件名称：PrettyZoo
功能：
节点 CRUD 节点实时同步 交互与原型：
交互分两部，第一步启动页面要求用户输入 zookeeper 的服务地址，连接成功后会跳到节点操作页面
​	技术方案：
语言采用 Java UI 框架采用 Swing 采用传统的分层架构 Zookeeper Client 采用 Apache Curator 最终实现：
不足：
受限于交互流程，一次只能管理一个 zookeeper server 由于是 Java8，运行需要安装额外的 JRE（或 JDK），影响了受众面 颜值不足 工程质量方面，架构分层不清晰，导致层与层之间相互渗透，随时膨胀为一个 Big Bom 界面与架构的重构规划 重构主要是为了解决上一版的不足，而第一步就是分析产生这些问题的根本原因，再提出对应的解决方案
一次只能管理一个 server
这是因为交互和设计上导致的，要解决该问题需要重新思考交互和软件的布局。
经过网上的调研，最终决定采用 “三栏布局”，即解决了以前交互模式的分割感，又满足了一次性管理多个 server 的需求。
需要额外安装 JRE
既然选择了 Java 作为开发语言，那么程序必然会依赖 JRE 来运行。此时再切换语言自然是不现实的，好在 Java9 的 模块化系统（Jigsaw）提供了另一个选择，细节就不在此深入讨论了。</description>
    </item>
    
    <item>
      <title>架构简谈：从分层到六边形</title>
      <link>https://blog.cc1234.cc/posts/hexagonal-arch/</link>
      <pubDate>Sat, 07 Dec 2019 11:49:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/hexagonal-arch/</guid>
      <description>分层架构 分层架构模式被认为是所有架构的始祖，该架构将系统从上至下划分为不同的层级，层与层之间定义了明确的依赖限制，按照限制的强弱可以分为严格分层和松散分层两种风格。
不管是严格分层还是松散分层，最基本的规则都一样：上层可以依赖下层，而下层不能依赖上层。
严格分层相对于松散分层的不同点在于是否限制同层依赖和跨层依赖。
分层架构强调层与层之间的边界，明确的边界可以降低耦合，使得职责更加清晰。
在分层中，底层往往比上层稳定，自上而下的依赖就完全符合了稳定依赖原则，如果采用严格分层模式（禁止同层依赖）的话，还可以避免循环依赖。
David Wheeler: All problems in computer science can be solved by another level of indirection
然而在现实系统开发中，随着业务的变化，分层架构也不是那么好把控的，主要在于以下几点
分层会增加，而新加的分层边界往往又不是很明确，这样就形成了一个模糊层
模糊层可能会形成隐藏的循环依赖
演进之路 下面以我们常见的三层架构来看看，分层是如何演进成为六边形架构的。
我想 controller =&amp;gt; service =&amp;gt; dao 是每个后端同学都很熟悉的架构了，这是一个很典型的分层架构，并没有什么多说的
当分层和 DIP (依赖倒置原则) 相遇时，会产生另外的化学反应。
controller 和 service 都依赖于 interface，dao 和 service 也都依赖于 interface。
这是一个非常典型的 DIP：抽象不应该依赖于细节，细节应该依赖于抽象
当我们再将这个依赖关系平铺开，就成了这个样子了。多层次关系被拍平了，只剩下内外两层。
这其实就是一个典型的六边形架构了，是不是感觉被糊弄了？
然而这就是事实，当分层架构和 DIP 结合起来的时候，我们已经在使用六边形架构的风格了。
那么难道 DIP + 分层 = 六边形架构 吗？，关于这个问题 Vaughn Vernon 在其著作《实现领域驱动设计》中有过解答：
很多声称使用分层架构的团队实际使用的是六边形架构。
这是因为很多项目都是用了某种形式的依赖注入，并不是说依赖注入天生就是六边形架构，而是依赖注入的架构自然的就有了六边形架构风格。
六边形架构 六边形架构是由 Alistair Cockburn 博士提出的，与分层架构按层级（从上至下或从左至右）看待系统不一样，六边形架构提倡用外部和内部的视角来看待系统。</description>
    </item>
    
    <item>
      <title>Java 模块化系统 Jigsaw</title>
      <link>https://blog.cc1234.cc/posts/java-jigsaw/</link>
      <pubDate>Thu, 24 Oct 2019 21:18:00 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/java-jigsaw/</guid>
      <description>历史 2017年9月21日 Java9 正式发布，其中最大的变化就是引入了代号为 Jigsaw 的模块化系统（Java Platform Module System，简称 JPMS）。
Java 的模块化系统可以说是一波三折，在 2005 年（Java7） 就已经有提案了（ JSR277 ），但是因为种种历史原因，在一年多后该提案又被取消掉了
直到 2014年，新的提案 JSR376 被提出，Java 的模块化系统才得以重新步入正轨，虽然它迟到了（原计划于 Java8 发布），但并没有缺席。
下图展示了从 JSR376 被提出到实现的各个阶段：
目标 在 JSR376 中，对模块化系统的目标是有非常明确的描述的：
使用更可靠的配置来描述程序组件之间的依赖关系，并以此替代问题频出的 class-path 组件可以控制其 API 被其他组件的访问性，提供一个更强的封装能力 增加 JavaSE 平台的扩展性，开发人员可以只将他需要的功能模块组装到一个自定义的配置中去 增强平台的完整性，确保平台内部 API 不会被访问 性能提升 实际上最核心的目标是最前面的两点，替代 class-path 和 增强封装性。
在 Project Jigsaw: Goals &amp;amp; Requirements DRAFT 3 里对于实现目标的描述可能更加通俗易懂一些。
初次接触 Java9 的模块化系统时，会不自觉的和 Maven、Gradle 等构建工具进行对比，但是实际上两者关注的核心点是不一样的。
模块化系统更注重模块之间的封装性，而构建工具更注重的是依赖管理和项目构建。
也就是说构建工具可以决定依赖某个第三方库，而模块系统则决定你能使用该第三方库的哪些包或类，两者并不是对立的。
这也恰好解释了为什么 Java 的模块化系统没有版本管理
语法 Java 的模块是在 package 之上提供的一层抽象，所以通常一个模块是由多个 package 聚合而成的。</description>
    </item>
    
    <item>
      <title>从30分钟到1分钟 - SBT的update耗时优化记录</title>
      <link>https://blog.cc1234.cc/posts/sbt-update-optimize/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/sbt-update-optimize/</guid>
      <description>前言 公司有项目是基于 Scala 编写的，与之配套的构建工具是 SBT , 它是 Simple Build Tool 的缩写，虽然我觉得它一点也不简单。
这个项目有一个很大的痛点就是刷新依赖 （对应 SBT 的 update）非常之耗时，可以参见下图：
注意图中红框部分，耗时1266秒，近半个小时。在刷新期间资源占用也很高，导致电脑很卡 （风扇还呼呼呼的转，温度蹭蹭蹭的长）。
最关键的是由于依赖的很多服务升级很快 （几乎每天都有升级），所以这个操作每天也会持续很多次，难以想象耗费在这方面的时间是何其之多。
人生苦短，在刷新了几次之后，我再也受不了这漫长的等待时间，于是开始了这漫漫的优化之路。
正所谓工欲善其事必先利其器
Round 1: 十八般武艺齐上阵 不知道大家碰见这种问题会怎么做，我反正是二话不说打开 Google 直接搜： SBT 依赖下载慢。
还别说，有共鸣的人还不少， 总结了下几乎都是以下的解决方案
添加代理 添加国内镜像源 我这肯定不是源的问题啊，我司用的私有仓库，既然私有jar都下载下来了，肯定是走的私有仓库啊。
翻了几页，没有满意的答案，也试了几个方案，也没啥用。
看来还是得自己从问题的根源开始找起啊&amp;hellip;&amp;hellip;
为了保险起见， 我还是先排查一下是不是镜像问题， 项目的 build.sbt 配置文件中是有私有仓库的相关配置项的：
lazy val commonSettings = Seq( //.... // ... 私有仓库 resolvers := {Resolver.url(&amp;#34;xr-ivy-releasez&amp;#34;, new URL(&amp;#34;http://nexus.xxxx.com/repository/ivy-releases/&amp;#34;))(Resolver.ivyStylePatterns) +: resolvers.value}, resolvers := { {&amp;#34;xr-maven-public&amp;#34; at &amp;#34;http://nexus.xxxx.com/repository/public/&amp;#34;} +: resolvers.value}, // .... ) 此时我忽然想到一种情况：难道是默认走的公共库，在公共库找不到依赖才会走私有库 ？</description>
    </item>
    
    <item>
      <title>简单聊聊TCP的可靠性</title>
      <link>https://blog.cc1234.cc/posts/tcp-reliability/</link>
      <pubDate>Fri, 30 Aug 2019 13:58:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/tcp-reliability/</guid>
      <description>前言 传输控制协议（缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。
TCP 在不可靠的 IP 协议之上实现了可靠性， 从而使得我们不必再去关注网络传输中的种种复杂性，所谓的可靠就是让我们去信任它即可。
信任归信任，可我们还是的得去了解它，知道它为何值得信任，信任主要体现在哪些方面，换句话说就是
TCP的可靠性是什么 TCP如何实现的可靠性 上面的问题就是本文讨论的核心点
TCP 的可靠性实则是一个很大的话题，很多细节都值得深究，由于本人水平有限，文中很多描述都没有深入甚至可能有错误，读者若有不同观点，尽可提出。
什么是可靠性 其实在 RFC 793 的 1.5 Operation 专门对 Reliability （可靠性）做了说明。
总结下来如下
确保一个进程从其接收缓存中读出的数据流是无损坏，无间隔，非冗余和按序的数据流；即字节流与连接的另一方端系统发送出的字节流是完全相同的
需要解决的问题 前面说到的可靠性，提到了无损坏，无间隔，非冗余和按序等几个关键词， 而在网络中要实现这些指标，我们都有对应的问题需要去解决。
其中最典型的几个问题如下
干扰
网络的干扰可能是因为硬件故障导致数据包受到破坏， 也有可能是网络波动导致数据包的某些 bit 位产生了变化
题外话：这里的干扰并不包含恶意攻击，恶意攻击是属于传输安全的范畴了，比如我们熟知的 SSL/TLS 就是一个成熟的网络传输安全问题的解决方案
如下图，发送的 111 由于干扰变成了 101
乱序
发送方连续先后发送两个数据包， 后发送的数据包可能先到达接收方，如果接收方按接收顺序处理数据包，这就会导致接收的数据包与发送的数据包不一致。
造成这样的原因是因为每一个数据包都会根据当时的网络情况选择不同的路由进行传输， 就像多个人开车从上海到北京有很多路线可选，不一定先出发就能先到（我没去过北京，请不要杠我&amp;hellip;&amp;hellip;）
如下图，发送方顺序发送了 A -&amp;gt; B -&amp;gt; C 三个数据包， 然而接收方可能是以 A -&amp;gt; C -&amp;gt; B 这样的顺序接收的报文，很明显 B 和 C 两个个报文的顺序不符合期望，产生了乱序
丢包</description>
    </item>
    
    <item>
      <title>Spring的循环依赖</title>
      <link>https://blog.cc1234.cc/posts/spring-circle-reference/</link>
      <pubDate>Thu, 22 Aug 2019 13:30:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/spring-circle-reference/</guid>
      <description>前言 本文最耗时间的点就在于想一个好的标题， 既要灿烂夺目，又要光华内敛，事实证明这比砍需求还要难！
由于对象之间的依赖关系经常是错综复杂，使用不当会引发很多意想不到的问题， 一个很典型的问题就是循环依赖 （也可以称之为循环引用）。
Spring 为我们提供了依赖注入，并且在某些情景（单例 Bean 的注入）下支持循环依赖的注入
本文的主要目的是分析 Spring 在 Bean 的创建中是如何处理循环依赖的。
我会从循环依赖是什么，以及它的坏处，到最后通过Spring的源码来看它是如何处理这个问题的。
循环依赖不仅仅是 Spring 的 Bean 之间会产生， 往大了看，系统模块之间会产生循环依赖， 系统与系统之间也会产生循环依赖，这是一个典型的坏味道，我们应该尽量避免。
什么是循环依赖 循环依赖指的是多个对象之间的依赖关系形成一个闭环。
下图展示了两个对象 A 和 B 形成的一个循环依赖
下图展示了多个对象形成的一个循环依赖
现实中由于依赖层次深、关系复杂等因素， 导致循环依赖可能并不是那么一目了然。
为什么要避免循环依赖 循环依赖会为系统带来很多意想不到的问题，下面我们来简单讨论一下
一、循环依赖会产生多米诺骨牌效应
换句话说就是牵一发而动全身，想象一下平静的湖面落入一颗石子，涟漪会瞬间向周围扩散。
循环依赖形成了一个环状依赖关系， 这个环中的某一点产生不稳定变化，都会导致整个环产生不稳定变化
实际的体验就是
难以为代码编写测试，因为易变导致写的测试也不稳定 难以重构，因为互相依赖，你改动一个自然会影响其他依赖对象 难以维护，你根本不敢想象你的改动会造成什么样的后果 &amp;hellip;&amp;hellip; 二、循环依赖会导致内存溢出
参考下面的代码
public class AService { private BService bService = new BService(); } public class BService { private AService aService = new AService(); } 当你通过 new AService() 创建一个对象时你会获得一个栈溢出的错误。</description>
    </item>
    
    <item>
      <title>带你破案：文件描述符到底是什么？</title>
      <link>https://blog.cc1234.cc/posts/file-descriptor/</link>
      <pubDate>Tue, 23 Jul 2019 23:34:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/file-descriptor/</guid>
      <description>前言 文件描述符在unix系统中几乎无处不在
网络接口 select、poll、epoll 涉及到文件描述符 IO接口 read、write 也涉及到文件描述符 从形式上来看文件描述就是一个整数，那么我们可不可以更进一步去了解一下呢？
本文打算通过一步一步实验去了解文件描述符到底是什么， 并在最后通过Linux内核相关的源码进行验证。
一个获取文件描述符的实例 我们可以通过 open 系统调用得到一个指定文件的文件描述符。
open 函数需要传入一个文件路径和操作模式， 调用会返回一个整型的文件描述符， 具体方法签名如下
/** * path 代表文件路径 * oflag 代表文件的打开模式，比如读，写等 */ int open(char *path, int oflag, ...) 我们写一段简单的代码来验证一下
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; int main(int argc, char* argv[]) { // 以只读模式打开 demo.txt 文件 int fd = open(&amp;#34;demo.txt&amp;#34;, O_RDONLY); if (fd == -1) { perror(&amp;#34;open demo.txt error\n&amp;#34;); return EXIT_FAILURE; } // 打印获取到的文件描述符 printf(&amp;#34;demo.txt fd = %d \n&amp;#34;, fd); return EXIT_SUCCESS; } 然后使用 GCC 编译，执行编译后的程序，我们就可以得到 demo.</description>
    </item>
    
    <item>
      <title>TCP之TCP_NODELAY</title>
      <link>https://blog.cc1234.cc/posts/tcp-nodelay/</link>
      <pubDate>Tue, 26 Mar 2019 14:08:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/tcp-nodelay/</guid>
      <description>0X00 前言 我们在使用socket（TCP）进行编程时会有很多配置选项, 而TCP_NODEPLAY也正是其中之一， 本文的目的就是研究TCP_NODELAY产生的效果以及其背后的原理。
0X01 TCP_DELAY与Nagle TCP_NODELAY的值为0或1（在有的语言中为true或false）， 当设置为1（true)时即代表着关闭Nagle算法， 反之则代表打开Nagle算法。
Nagle算法由John Nagle发明， 该算法旨在通过减少发送网络包的数量从而提升网络的性能。
那么它是如何减少发送的包数量的呢， 这又得了解作者描述的一个问题 &amp;ndash; “小数据包问题”：
应用不断的提交小单为的数据， 经常只有1byte大小，而为了发送这1byte的数据， 还需要传输40byte的数据首部包(TCP首部 20byte + IPV4首部 20byte), 从而对网络造成了巨大的开销
为了解决这个问题，Nagle算法就应运而生了， 下面是该算法的伪码
# MSS代表最大分段大小， 可以理解为TCP愿意接受的数据的字节数最大值 # the window size代表接收窗口的大小 if there is new data to send if the window size &amp;gt;= MSS and available data is &amp;gt;= MSS send complete MSS segment now else # 如果存在未被确认的数据 if there is unconfirmed data still in the pipe # 将该数据加入缓冲， 当接收方一个确认保文返回时就发送该缓冲内的数据 enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if 我们主要关注Nagle算法对数据合并的方式和时机，以及发送合并数据的时机， 参考下图</description>
    </item>
    
    <item>
      <title>LeetCode-33-Search in rotated sorted array</title>
      <link>https://blog.cc1234.cc/posts/leetcode-33/</link>
      <pubDate>Fri, 11 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/leetcode-33/</guid>
      <description>题意 假设有一个按升序排列的数组， 现在将其从中间某个位置（未知）将其分成两部分，并交换位置
原数组：[0,1,3,5,6,7,8] 将其分为两部分，索引&amp;lt;4 算一部分， 剩余的为第二部分 将其旋转后得到 [6,7,8,0,1,3,5] 现在你需要在这个旋转后的数组种找寻是否有输入的一个目标值， 如果有就返回它在数组中的索引位置，否则返回-1.
约束条件：
数组中的值都是不重复的 算法的时间复杂度必须是O(logN) 思路 注意理解两个约束条件（很重要）， 第二个条件要求时间复杂度必须是O(logN), 而在数组查找问题中看见O(logN)我们一般会想到二分查找法（又叫折半查找法）
但是二分查找要求整个输入必须是有序的， 而我们这个输入明显不符合要求。
二分查找一次排除一半的结果集，这是因为能确定结果不在其中，根据这个思路我们还是有希望用二分查找解决这个问题的。
但是我们得先分析旋转后的数组情况， 以便找出一定的规律每次去排除一半的结果集
首先根据题意， 我们得知输入数组最开始是升序的， 只不过要经历一次旋转， 而旋转的位置是未知的。
如果我们给定的旋转位置比0还小的话， 这样数组就不会变化，结构如下图，即 x~y 为升序, 这种情况用正常的二分查找就能解决问题了。
分析 如果给定的旋转位置&amp;gt;=0并且合法，那么数组会被我们分成A,B两部分， 这就会存在以下两种情况
A.length &amp;gt; B.length A.length &amp;lt;= B.length 下面用图来说明这两种情况， 在图中蓝色区域为A, 红色区域为B
先看第一种情况: A.length &amp;gt; B.length
这种情况下
x &amp;lt; m, n &amp;lt; y, m &amp;lt; n, x &amp;lt; y; 这种情况下使用二分查找计算得到的中间位置midle就落在蓝色区域内
如果 array[midle] &amp;lt; target : 红色部分肯定小于array[midle] , 而midle～y为升序， 我们就能确定值在 middle + 1 ~ y之间</description>
    </item>
    
    <item>
      <title>操作系统之保护模式简谈</title>
      <link>https://blog.cc1234.cc/posts/os-protect-mode/</link>
      <pubDate>Sun, 30 Dec 2018 18:08:06 +0800</pubDate>
      
      <guid>https://blog.cc1234.cc/posts/os-protect-mode/</guid>
      <description>前言 如果你想学习或者自己尝试写一个操作系统内核，保护模式是你绕不开的一个话题。
这篇文章的主要目的是让你了解保护模式个东西，以及它的作用。
不会涉及到如何进入保护模式，以及保护模式的一些细节我也会有意略过，
希望你在读这篇文章的时候，能了解计算机的组成， 对CPU的寄存器体系有一定的了解。
历史 保护模式是CPU的一种运行模式，出现在80286及之后的X86架构的CPU下。
这里说的CPU运行模式主要体现在CPU在内存寻址的区别。
在80286之前只有一种运行模式， 由于保护模式和这种模式有非常大的区别， 为了便于区分，便将以前的运行模式称之为实模式， CPU默认是工作在实模式下的。
实模式 最开始的8086最大寻址空间为1MB(即2^20), 但是8086的内部寄存器只有16位，那么如何能够做到1MB的内存寻址呢？Intel采用了以下的方式
内存地址 = 16位段寄存器 &amp;laquo; 4 + 16位通用寄存器保存的地址偏移
这样也会出现一个问题：即最终计算的内存地址会大于2^20 , 此时回产生内存回卷
回卷就是把溢出的最高位1和低16位做加法运算。例如：原本是（1）0100101011000001，回卷就是0100101011000001+1=0100101011000010
这个就是CPU默认的运行模式&amp;ndash;实模式的最大特点了。
保护模式 80286之后出现的保护模式，不仅仅改变了内存的寻址方式，还增加了存储器保护，标签页系统以及硬件支持的虚拟内存等特性。
为了兼容， 该模式默认是关闭的， 要由程序（通常是系统内核）主动切换。
为什么要有保护模式呢？因为80286的内存寻址空间达到16MB， 而80386更是达到了4GB, 实模式没法满足寻址的要求了。
下面我们就来讲一下保护模式是如何实现以上特性的。
在我们切换到保护模式之前我们要准备一个数据结构**全局描述符表， 它的本质是一个数组， 数组中的每一个元素称为全局描述符**， 这是一个64位的数据结构。
数据结构看着有点怪是不是？这其实是历史原因
全局描述符包含可访问的内存的基址， 最大长度， 以及其他的一些权限位。
这个全局描述符的地址被放在了一个称之为 GDTR的寄存器中
现在的段寄存器存储的就是全局描述符表的索引， 我们一般称之为段选择子
实际上段选择子的高13位存储的是索引， 低3位用来存储和权限相关的bit, 可以参考下图
这样的话我们的寻址方式就变成了以下流程了
从GDTR取得全局描述符表的地址 从段选择子取得索引 idx， 然后用 idx * 64 + 全局描述符的地址 得到 一个全局描述符的地址（前面我们讲过一个描述符是64bit的数据结构） 从全局描述符我们可以拿到内存的BaseAddress, 用BaseAddress + 16位通用寄存器的偏移 就可以得到最终的物理内存地址 注意， 我有意跳过了相关的权限检查的流程， 参考下图(目前得到的线性地址-Linear address 就是物理内存地址)</description>
    </item>
    
  </channel>
</rss>
