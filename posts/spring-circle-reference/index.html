<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        

		<meta name="author" content="vran">
		
		<meta name="generator" content="Hugo 0.80.0" />
		<title>Spring的循环依赖 &middot; 且徐行</title>
		<link rel="shortcut icon" href="https://blog.cc1234.cc/images/favicon.ico">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/style.css">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/highlight.css">
</head>


<body>
    <section id="single" class="wrapper">
    


<nav class="nav-main">
         
         <a href='https://blog.cc1234.cc/'> Home</a>
         <a href='https://blog.cc1234.cc/posts'>Archive</a> 
         <a href='https://blog.cc1234.cc/tags'>Tags</a> 
         <a href='https://blog.cc1234.cc/about'>About</a>

        
        
</nav>


        <article class = "post">
            <header>
                <div class = "post-img">
                    
                </div>
                <div class = title>
                    Spring的循环依赖
                </div>
                <div class="meta">
                2019/08/22
                · vran
                </div>
            </header>
            <div class = "line"></div>
            
            <section class="content">
                <h2 id="前言">前言</h2>
<blockquote>
<p>本文最耗时间的点就在于想一个好的标题， 既要灿烂夺目，又要光华内敛，事实证明这比砍需求还要难！</p>
</blockquote>
<p>由于对象之间的依赖关系经常是错综复杂，使用不当会引发很多意想不到的问题， 一个很典型的问题就是<strong>循环依赖</strong> （也可以称之为<strong>循环引用</strong>）。</p>
<p>Spring 为我们提供了依赖注入，并且在某些情景（单例 Bean 的注入）下支持循环依赖的注入</p>
<p>本文的主要目的是分析 Spring 在 Bean 的创建中是如何处理循环依赖的。</p>
<p>我会从循环依赖是什么，以及它的坏处，到最后通过Spring的源码来看它是如何处理这个问题的。</p>
<blockquote>
<p>循环依赖不仅仅是 Spring 的 Bean 之间会产生， 往大了看，系统模块之间会产生循环依赖， 系统与系统之间也会产生循环依赖，这是一个典型的坏味道，我们应该尽量避免。</p>
</blockquote>
<h2 id="什么是循环依赖">什么是循环依赖</h2>
<p>循环依赖指的是<strong>多个对象之间的依赖关系形成一个闭环</strong>。</p>
<p>下图展示了两个对象 A 和 B 形成的一个循环依赖</p>
<p><img src="img/circular-reference.png" alt="image-20190820121530408"></p>
<p>下图展示了多个对象形成的一个循环依赖</p>
<p><img src="img/circular-reference2.png" alt="image-20190820204151669"></p>
<p>现实中由于依赖层次深、关系复杂等因素， 导致循环依赖可能并不是那么一目了然。</p>
<h2 id="为什么要避免循环依赖">为什么要避免循环依赖</h2>
<p>循环依赖会为系统带来很多意想不到的问题，下面我们来简单讨论一下</p>
<p>一、<strong>循环依赖会产生多米诺骨牌效应</strong></p>
<p>换句话说就是牵一发而动全身，想象一下平静的湖面落入一颗石子，涟漪会瞬间向周围扩散。</p>
<p>循环依赖形成了一个环状依赖关系， 这个环中的某一点产生不稳定变化，都会导致整个环产生不稳定变化</p>
<p>实际的体验就是</p>
<ul>
<li>难以为代码编写测试，因为易变导致写的测试也不稳定</li>
<li>难以重构，因为互相依赖，你改动一个自然会影响其他依赖对象</li>
<li>难以维护，你根本不敢想象你的改动会造成什么样的后果</li>
<li>&hellip;&hellip;</li>
</ul>
<p>二、<strong>循环依赖会导致内存溢出</strong></p>
<p>参考下面的代码</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">AService</span> <span style="color:#000">{</span>
  <span style="color:#a90d91">private</span> <span style="color:#000">BService</span> <span style="color:#000">bService</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">BService</span><span style="color:#000">();</span>
<span style="color:#000">}</span>

<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">BService</span> <span style="color:#000">{</span>
  <span style="color:#a90d91">private</span> <span style="color:#000">AService</span> <span style="color:#000">aService</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">AService</span><span style="color:#000">();</span>
<span style="color:#000">}</span>
</code></pre></div><p>当你通过 <code>new AService()</code> 创建一个对象时你会获得一个栈溢出的错误。</p>
<p>如果你了解 <strong>Java</strong> 的初始化顺序就应该知道为什么会出现这样的问题。</p>
<p>因为调用 <code>new AService()</code> 时会先去执行属性 bService 的初始化, 而 bService 的初始化又会去执行 AService 的初始化， 这样就形成了一个循环调用，最终导致调用栈内存溢出。</p>
<h2 id="spring的循环依赖示例">Spring的循环依赖示例</h2>
<p>下面我们通过简单的示例来展示 Spring 中的循环依赖注入， 我分别展示了一个构造器注入和 Field 注入的循环依赖示例</p>
<ul>
<li>
<p>构造器注入</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">@Service</span>
<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">AService</span> <span style="color:#000">{</span>
    
  <span style="color:#a90d91">private</span> <span style="color:#a90d91">final</span> <span style="color:#000">BService</span> <span style="color:#000">bService</span><span style="color:#000">;</span>
    
  <span style="color:#000">@Autowired</span>
  <span style="color:#a90d91">public</span> <span style="color:#000">AService</span><span style="color:#000">(</span><span style="color:#000">BService</span> <span style="color:#000">bService</span><span style="color:#000">)</span> <span style="color:#000">{</span>
    <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">BService</span> <span style="color:#000">=</span> <span style="color:#000">bService</span>
  <span style="color:#000">}</span>
    
<span style="color:#000">}</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">@Service</span>
<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">BService</span> <span style="color:#000">{</span>
    
  <span style="color:#a90d91">private</span> <span style="color:#a90d91">final</span> <span style="color:#000">AService</span> <span style="color:#000">aService</span><span style="color:#000">;</span>
    
  <span style="color:#000">@Autowired</span>
  <span style="color:#a90d91">public</span> <span style="color:#000">BService</span><span style="color:#000">(</span><span style="color:#000">AService</span> <span style="color:#000">aService</span><span style="color:#000">)</span> <span style="color:#000">{</span>
    <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">aService</span> <span style="color:#000">=</span> <span style="color:#000">aService</span><span style="color:#000">;</span>
  <span style="color:#000">}</span>
    
<span style="color:#000">}</span>
</code></pre></div></li>
<li>
<p>Field注入</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">@Service</span>
<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">AService</span> <span style="color:#000">{</span>
    
  <span style="color:#000">@Autowired</span>
  <span style="color:#a90d91">private</span> <span style="color:#000">BService</span> <span style="color:#000">bService</span><span style="color:#000">;</span>
    
<span style="color:#000">}</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">@Service</span>
<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">BService</span> <span style="color:#000">{</span>
    
  <span style="color:#000">@Autowired</span>
  <span style="color:#a90d91">private</span> <span style="color:#000">AService</span> <span style="color:#000">aService</span><span style="color:#000">;</span>
    
<span style="color:#000">}</span>
</code></pre></div><p><code>Setter</code>注入和 Feild注入 类似</p>
</li>
</ul>
<p>如果你启动 Spring 容器的话， <strong>构造器注入</strong>的方式会抛出异常 BeanCreationException ， 提示你出现了循环依赖。</p>
<p>但是 Field 注入的方式就会正常启动，并注入成功。</p>
<p>这说明 Spring 虽然能够处理循环依赖，但前提条件时你得按照它能够处理的方式去做才行。</p>
<p>比如 prototype 的 Bean 也不能处理循环依赖的注入，这点我们需要注意。</p>
<h2 id="一个检测循环依赖的方法">一个检测循环依赖的方法</h2>
<p>在我们具体分析 Spring 的 Field 注入是如何解决循环依赖时， 我们来看看如何到检测循环依赖。</p>
<p>在一个循环依赖的场景中，我们可以确定以下约束</p>
<ol>
<li>依赖关系是一个图的结构</li>
<li>依赖是有向的</li>
<li>循环依赖说明依赖关系产生了环</li>
</ol>
<p>明确后，我们就能知道检测循环依赖本质就是在<strong>检测一个图中是否出现了环</strong>， 这是一个很简单的算法问题。</p>
<p>利用一个 <code>HashSet</code> 依次记录这个依赖关系方向中出现的元素， 当出现重复元素时就说明产生了<code>环</code>， 而且这个重复元素就是环的起点。</p>
<p>参考下图， 红色的节点就代表是循环出现的点</p>
<p><img src="img/circurlar-reference-Detection.png" alt="image-20190820214157160"></p>
<p>以第一个图为例，依赖方向为 A-&gt;B-&gt;C-&gt;A ，很容易检测到 A 就是环状点。</p>
<h2 id="spring是如何处理循环依赖的">Spring是如何处理循环依赖的</h2>
<p>Spring 能够处理 <strong>单例Bean</strong> 的循环依赖（<strong>Field注入方式</strong>)，本节我们就通过纸上谈兵的方式来看看它是如何做到的。</p>
<p>首先，我们将 Spring 创建 Bean 的生命周期简化为两个步骤：实例化 -&gt; 依赖注入， 如下图所示</p>
<p><img src="img/init-bean.png" alt="image-20190821084913337"></p>
<p><strong>实例化</strong>就相当于通过 <code>new</code> 创建了一个具体的对象， 而<strong>依赖注入</strong>就相当于为对象的属性进行赋值操作</p>
<p>我们再将这个过程扩展到两个相互依赖 Bean 的创建过程上去,  如下图所示</p>
<p><img src="img/init-cicular-bean.png" alt="image-20190821085026269"></p>
<p>A 在执行依赖注入时需要实例化 B， 而 B 在执行依赖注入时又会实例化 A ，形成了一个很典型的依赖环。</p>
<p>产生环的节点就是 B 在执行依赖注入的阶段， 如果我们将其&quot;砍”掉， 就没有环了， 如下图所示</p>
<p><img src="img/resolve-circular-bean.png" alt="image-20190821085058598"></p>
<p>这样做确实没有循环依赖了，但却带来了另一个问题，B 是没有经过依赖注入的， 也就是说 B 是不完整的， 这怎么办呢？</p>
<p>此时 A 已经创建完成并维护在 Spring 容器内，A 持有 B 的引用， 并且 Spring 维护着未进行依赖注入的 B 的引用。</p>
<p>当 Spring <strong>主动创建</strong> B 时可以直接取得 B 的引用 （省去了实例化的过程）， 当执行依赖注入时， 也可以直接从容器内取得 A 的引用， 这样 B 就创建完成了</p>
<p><img src="img/circular-refernce-resolve.png" alt="image-20190821090540301"></p>
<p>A 持有的未进行依赖注入的 B，和后面单独创建 B 流程里面是同一个引用对象， 当 B 执行完依赖注入后，A 持有的 B 也就是一个完整的 Bean了。</p>
<h2 id="show-me-the-code">Show me the code</h2>
<blockquote>
<p>没有代码的泛泛而谈是没有灵魂的</p>
</blockquote>
<p>我画了一个简化的流程图来展示一个 Bean 的创建（省略了 Spring 的 BeanPostProcessor，Aware 等事件）过程， 希望你过一遍，然后我们再去看源码。</p>
<p>入口直接从 <code>getBean(String)</code> 方法开始， 以 <code>populateBean</code> 结束， 用于分析循环依赖的处理是足够的了</p>
<p><img src="img/spring-di.png" alt="image-20190821130844906"></p>
<p><code>getBean(String)</code> 是 <strong>AbstractBeanFactory</strong> 的方法,  它内部调用了  <code>doGetBean</code> 方法， 下面是源码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">abstract</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">AbstractBeanFactory</span> <span style="color:#a90d91">extends</span> <span style="color:#000">FactoryBeanRegistrySupport</span> <span style="color:#a90d91">implements</span> <span style="color:#000">ConfigurableBeanFactory</span> <span style="color:#000">{</span>
 	<span style="color:#000">@Override</span>
	<span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getBean</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">name</span><span style="color:#000">)</span> <span style="color:#a90d91">throws</span> <span style="color:#000">BeansException</span> <span style="color:#000">{</span>
		<span style="color:#a90d91">return</span> <span style="color:#000">doGetBean</span><span style="color:#000">(</span><span style="color:#000">name</span><span style="color:#000">,</span> <span style="color:#a90d91">null</span><span style="color:#000">,</span> <span style="color:#a90d91">null</span><span style="color:#000">,</span> <span style="color:#a90d91">false</span><span style="color:#000">);</span>
	<span style="color:#000">}</span>
  
  <span style="color:#a90d91">protected</span> <span style="color:#000">&lt;</span><span style="color:#000">T</span><span style="color:#000">&gt;</span> <span style="color:#000">T</span> <span style="color:#000">doGetBean</span><span style="color:#000">(</span><span style="color:#a90d91">final</span> <span style="color:#000">String</span> <span style="color:#000">name</span><span style="color:#000">,</span> <span style="color:#a90d91">final</span> <span style="color:#000">Class</span><span style="color:#000">&lt;</span><span style="color:#000">T</span><span style="color:#000">&gt;</span> <span style="color:#000">requiredType</span><span style="color:#000">,</span> <span style="color:#a90d91">final</span> <span style="color:#000">Object</span><span style="color:#000">[]</span> <span style="color:#000">args</span><span style="color:#000">,</span> <span style="color:#a90d91">boolean</span> <span style="color:#000">typeCheckOnly</span><span style="color:#000">){</span>
    <span style="color:#000">...</span>
    <span style="color:#177500">// #1
</span><span style="color:#177500"></span>    <span style="color:#000">Object</span> <span style="color:#000">sharedInstance</span> <span style="color:#000">=</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
    <span style="color:#000">...</span>
    <span style="color:#a90d91">final</span> <span style="color:#000">RootBeanDefinition</span> <span style="color:#000">mbd</span> <span style="color:#000">=</span> <span style="color:#000">getMergedLocalBeanDefinition</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
    <span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">mbd</span><span style="color:#000">.</span><span style="color:#836c28">isSingleton</span><span style="color:#000">())</span> <span style="color:#000">{</span>
      <span style="color:#177500">// #2
</span><span style="color:#177500"></span>    	<span style="color:#000">sharedInstance</span> <span style="color:#000">=</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">new</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;</span><span style="color:#000">Object</span><span style="color:#000">&gt;()</span> <span style="color:#000">{</span>
						<span style="color:#000">@Override</span>
						<span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getObject</span><span style="color:#000">()</span> <span style="color:#a90d91">throws</span> <span style="color:#000">BeansException</span> <span style="color:#000">{</span>
              	<span style="color:#177500">// #3
</span><span style="color:#177500"></span>								<span style="color:#a90d91">return</span> <span style="color:#000">createBean</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">args</span><span style="color:#000">);</span>
						<span style="color:#000">}</span>
					<span style="color:#000">});</span>
    <span style="color:#000">}</span>
    <span style="color:#000">...</span>
    <span style="color:#a90d91">return</span> <span style="color:#000">(</span><span style="color:#000">T</span><span style="color:#000">)</span><span style="color:#000">bean</span><span style="color:#000">;</span>
  <span style="color:#000">}</span>
<span style="color:#000">}</span>
</code></pre></div><p>我简化了 <code>doGetBean</code> 的方法体，与流程图对应起来，使得我们可以轻松找到下面的调用流程</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">doGetBean</span> <span style="color:#000">-&gt;</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">String</span><span style="color:#000">)</span> <span style="color:#000">-&gt;</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">)</span>
</code></pre></div><p><code>getSingleton</code> 是 <strong>DefaultSingletonBeanRegistry</strong> 的重载方法</p>
<p><strong>DefaultSingletonBeanRegistry</strong> 维护了三个 <strong>Map</strong> 用于缓存不同状态的 Bean,  稍后我们分析 <code>getSingleton</code> 时会用到</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#177500">/** 维护着所有创建完成的Bean */</span>
<span style="color:#a90d91">private</span> <span style="color:#a90d91">final</span> <span style="color:#000">Map</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">Object</span><span style="color:#000">&gt;</span> <span style="color:#000">singletonObjects</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">ConcurrentHashMap</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">Object</span><span style="color:#000">&gt;(</span><span style="color:#000">256</span><span style="color:#000">);</span>

<span style="color:#177500">/** 维护着创建中Bean的ObjectFactory */</span>
<span style="color:#a90d91">private</span> <span style="color:#a90d91">final</span> <span style="color:#000">Map</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;?&gt;&gt;</span> <span style="color:#000">singletonFactories</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">HashMap</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;?&gt;&gt;(</span><span style="color:#000">16</span><span style="color:#000">);</span>

<span style="color:#177500">/** 维护着所有半成品的Bean */</span>
<span style="color:#a90d91">private</span> <span style="color:#a90d91">final</span> <span style="color:#000">Map</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">Object</span><span style="color:#000">&gt;</span> <span style="color:#000">earlySingletonObjects</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">HashMap</span><span style="color:#000">&lt;</span><span style="color:#000">String</span><span style="color:#000">,</span> <span style="color:#000">Object</span><span style="color:#000">&gt;(</span><span style="color:#000">16</span><span style="color:#000">);</span>
</code></pre></div><p><code>getSingleton(String)</code>  调用了重载方法  <code>getSingleton(String, boolean)</code>， 而该方法实际就是一个查询 Bean 的实现， 先看图再看代码：</p>
<p><img src="img/getSingleton.png" alt="image-20190821143946283"></p>
<p>从图中我们可以看见如下查询层次</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">singletonObjects</span> <span style="color:#000">=&gt;</span>  <span style="color:#000">earlySingletonObjects</span> <span style="color:#000">=&gt;</span> <span style="color:#000">singletonFactories</span>
</code></pre></div><p>再结合源码</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">DefaultSingletonBeanRegistry</span> <span style="color:#a90d91">extends</span> <span style="color:#000">SimpleAliasRegistry</span> <span style="color:#a90d91">implements</span> <span style="color:#000">SingletonBeanRegistry</span> <span style="color:#000">{</span>
  <span style="color:#000">@Override</span>
	<span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">beanName</span><span style="color:#000">)</span> <span style="color:#000">{</span>
		<span style="color:#a90d91">return</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">true</span><span style="color:#000">);</span>
	<span style="color:#000">}</span>
  
  <span style="color:#a90d91">protected</span> <span style="color:#000">Object</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">boolean</span> <span style="color:#000">allowEarlyReference</span><span style="color:#000">)</span> <span style="color:#000">{</span>
    <span style="color:#177500">// 从singletonObjects获取已创建的Bean
</span><span style="color:#177500"></span>		<span style="color:#000">Object</span> <span style="color:#000">singletonObject</span> <span style="color:#000">=</span> <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">singletonObjects</span><span style="color:#000">.</span><span style="color:#836c28">get</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
    
    <span style="color:#177500">// 如果没有已创建的Bean， 但是该Bean正在创建中
</span><span style="color:#177500"></span>		<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">singletonObject</span> <span style="color:#000">==</span> <span style="color:#a90d91">null</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">isSingletonCurrentlyInCreation</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">))</span> <span style="color:#000">{</span>
        <span style="color:#177500">// 从earlySingletonObjects获取已经实例化的Bean
</span><span style="color:#177500"></span>				<span style="color:#000">singletonObject</span> <span style="color:#000">=</span> <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">earlySingletonObjects</span><span style="color:#000">.</span><span style="color:#836c28">get</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
      
      	<span style="color:#177500">// 如果没有实例化的Bean， 但是参数allowEarlyReference为true
</span><span style="color:#177500"></span>				<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">singletonObject</span> <span style="color:#000">==</span> <span style="color:#a90d91">null</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">allowEarlyReference</span><span style="color:#000">)</span> <span style="color:#000">{</span>
          <span style="color:#177500">// 从singletonFactories获取ObjectFactory
</span><span style="color:#177500"></span>					<span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;?&gt;</span> <span style="color:#000">singletonFactory</span> <span style="color:#000">=</span> <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">singletonFactories</span><span style="color:#000">.</span><span style="color:#836c28">get</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
					<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">singletonFactory</span> <span style="color:#000">!=</span> <span style="color:#a90d91">null</span><span style="color:#000">)</span> <span style="color:#000">{</span>
            <span style="color:#177500">// 使用ObjectFactory获取Bean实例
</span><span style="color:#177500"></span>						<span style="color:#000">singletonObject</span> <span style="color:#000">=</span> <span style="color:#000">singletonFactory</span><span style="color:#000">.</span><span style="color:#836c28">getObject</span><span style="color:#000">();</span>
            
            <span style="color:#177500">// 保存实例， 并清理ObjectFactory
</span><span style="color:#177500"></span>						<span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">earlySingletonObjects</span><span style="color:#000">.</span><span style="color:#836c28">put</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">singletonObject</span><span style="color:#000">);</span>
						<span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">singletonFactories</span><span style="color:#000">.</span><span style="color:#836c28">remove</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
					<span style="color:#000">}</span>
				<span style="color:#000">}</span>
		<span style="color:#000">}</span>
		<span style="color:#a90d91">return</span> <span style="color:#000">(</span><span style="color:#000">singletonObject</span> <span style="color:#000">!=</span> <span style="color:#000">NULL_OBJECT</span> <span style="color:#000">?</span> <span style="color:#000">singletonObject</span> <span style="color:#000">:</span> <span style="color:#a90d91">null</span><span style="color:#000">);</span>
	<span style="color:#000">}</span>
  
<span style="color:#000">}</span>

</code></pre></div><p>通过 <code>getSingleton(String)</code> 没有找到Bean的话就会继续往下调用 <code>getSingleton(String, ObjectFactory)</code> ,  这也是个重载方法， 源码如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;?&gt;</span> <span style="color:#000">singletonFactory</span><span style="color:#000">)</span> <span style="color:#000">{</span>
		<span style="color:#000">...</span>	
    <span style="color:#177500">// 获取缓存的Bean
</span><span style="color:#177500"></span>    <span style="color:#000">Object</span> <span style="color:#000">singletonObject</span> <span style="color:#000">=</span> <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">singletonObjects</span><span style="color:#000">.</span><span style="color:#836c28">get</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
			<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">singletonObject</span> <span style="color:#000">==</span> <span style="color:#a90d91">null</span><span style="color:#000">)</span> <span style="color:#000">{</span>
				<span style="color:#000">...</span>
        <span style="color:#177500">// 标记Bean在创建中
</span><span style="color:#177500"></span>        <span style="color:#000">beforeSingletonCreation</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">);</span>
				<span style="color:#a90d91">boolean</span> <span style="color:#000">newSingleton</span> <span style="color:#000">=</span> <span style="color:#a90d91">false</span><span style="color:#000">;</span>
				<span style="color:#000">...</span>
        <span style="color:#177500">// 创建新的Bean， 实际就是调用createBean方法
</span><span style="color:#177500"></span>        <span style="color:#000">singletonObject</span> <span style="color:#000">=</span> <span style="color:#000">singletonFactory</span><span style="color:#000">.</span><span style="color:#836c28">getObject</span><span style="color:#000">();</span>
        <span style="color:#000">newSingleton</span> <span style="color:#000">=</span> <span style="color:#a90d91">true</span><span style="color:#000">;</span>
				<span style="color:#000">...</span>
				<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">newSingleton</span><span style="color:#000">)</span> <span style="color:#000">{</span>
          <span style="color:#177500">// 缓存bean
</span><span style="color:#177500"></span>					<span style="color:#000">addSingleton</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">singletonObject</span><span style="color:#000">);</span>
				<span style="color:#000">}</span>
			<span style="color:#000">}</span>
			<span style="color:#a90d91">return</span> <span style="color:#000">(</span><span style="color:#000">singletonObject</span> <span style="color:#000">!=</span> <span style="color:#000">NULL_OBJECT</span> <span style="color:#000">?</span> <span style="color:#000">singletonObject</span> <span style="color:#000">:</span> <span style="color:#a90d91">null</span><span style="color:#000">);</span>
	<span style="color:#000">}</span>
</code></pre></div><p>流程很清晰，就没必要再画图了，简单来说就是根据 beanName 找不到 Bean 的话就使用传入的 ObjectFactory 创建一个 Bean。</p>
<p>从最开始的代码片段我们可以知道这个 ObjectFactory 的 getObject 方法实际就是调用了 <code>createBean</code> 方法</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">sharedInstance</span> <span style="color:#000">=</span> <span style="color:#000">getSingleton</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">new</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;</span><span style="color:#000">Object</span><span style="color:#000">&gt;()</span> <span style="color:#000">{</span>
						<span style="color:#000">@Override</span>
						<span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getObject</span><span style="color:#000">()</span> <span style="color:#a90d91">throws</span> <span style="color:#000">BeansException</span> <span style="color:#000">{</span>
              	<span style="color:#177500">// #3
</span><span style="color:#177500"></span>								<span style="color:#a90d91">return</span> <span style="color:#000">createBean</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">args</span><span style="color:#000">);</span>
						<span style="color:#000">}</span>
					<span style="color:#000">});</span>
</code></pre></div><p><code>createBean</code> 是 <strong>AbstractAutowireCapableBeanFactory</strong> 实现的，内部调用了 <code>doCreateBean</code> 方法</p>
<p><code>doCreateBean</code> 承担了 bean 的实例化，依赖注入等职责。</p>
<p>参考下图</p>
<p><img src="img/doCreateBean.png" alt="image-20190821154219474"></p>
<p><code>createBeanInstance</code> 负责实例化一个 Bean 对象。</p>
<p><code>addSingletonFactory</code> 会将单例对象的引用通过 ObjectFactory 保存下来， 然后将该 ObjectFactory 缓存在 <strong>Map</strong> 中（该方法在依赖注入之前执行）。</p>
<p><code>populateBean</code> 主要是执行依赖注入。</p>
<p>下面是源码， 基本与上面的流程图保持一致， 细节的地方我也标了注释了</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">abstract</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">AbstractAutowireCapableBeanFactory</span> <span style="color:#a90d91">extends</span> <span style="color:#000">AbstractBeanFactory</span>
      <span style="color:#a90d91">implements</span> <span style="color:#000">AutowireCapableBeanFactory</span> <span style="color:#000">{</span>
	<span style="color:#000">@Override</span>
	<span style="color:#a90d91">protected</span> <span style="color:#000">Object</span> <span style="color:#000">createBean</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">RootBeanDefinition</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">Object</span><span style="color:#000">[]</span> <span style="color:#000">args</span><span style="color:#000">)</span> <span style="color:#a90d91">throws</span> <span style="color:#000">BeanCreationException</span> <span style="color:#000">{</span>
		<span style="color:#000">...</span>
		<span style="color:#a90d91">return</span> <span style="color:#000">doCreateBean</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbdToUse</span><span style="color:#000">,</span> <span style="color:#000">args</span><span style="color:#000">);</span>
	<span style="color:#000">}</span>
	
	<span style="color:#a90d91">protected</span> <span style="color:#000">Object</span> <span style="color:#000">doCreateBean</span><span style="color:#000">(</span><span style="color:#a90d91">final</span> <span style="color:#000">String</span> <span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">final</span> <span style="color:#000">RootBeanDefinition</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#a90d91">final</span> <span style="color:#000">Object</span><span style="color:#000">[]</span> <span style="color:#000">args</span><span style="color:#000">)</span> <span style="color:#000">{</span>
		<span style="color:#000">...</span>
		<span style="color:#000">BeanWrapper</span> <span style="color:#000">instanceWrapper</span> <span style="color:#000">=</span> <span style="color:#a90d91">null</span><span style="color:#000">;</span>
		<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">instanceWrapper</span> <span style="color:#000">==</span> <span style="color:#a90d91">null</span><span style="color:#000">)</span> <span style="color:#000">{</span>
			<span style="color:#177500">// 实例化Bean
</span><span style="color:#177500"></span>			<span style="color:#000">instanceWrapper</span> <span style="color:#000">=</span> <span style="color:#000">createBeanInstance</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">args</span><span style="color:#000">);</span>
		<span style="color:#000">}</span>
		<span style="color:#a90d91">final</span> <span style="color:#000">Object</span> <span style="color:#000">bean</span> <span style="color:#000">=</span> <span style="color:#000">(</span><span style="color:#000">instanceWrapper</span> <span style="color:#000">!=</span> <span style="color:#a90d91">null</span> <span style="color:#000">?</span> <span style="color:#000">instanceWrapper</span><span style="color:#000">.</span><span style="color:#836c28">getWrappedInstance</span><span style="color:#000">()</span> <span style="color:#000">:</span> <span style="color:#a90d91">null</span><span style="color:#000">);</span>
		<span style="color:#177500">// 允许单例Bean的提前暴露
</span><span style="color:#177500"></span>		<span style="color:#a90d91">boolean</span> <span style="color:#000">earlySingletonExposure</span> <span style="color:#000">=</span> <span style="color:#000">(</span><span style="color:#000">mbd</span><span style="color:#000">.</span><span style="color:#836c28">isSingleton</span><span style="color:#000">()</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#a90d91">this</span><span style="color:#000">.</span><span style="color:#836c28">allowCircularReferences</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">isSingletonCurrentlyInCreation</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">));</span>
		<span style="color:#a90d91">if</span> <span style="color:#000">(</span><span style="color:#000">earlySingletonExposure</span><span style="color:#000">)</span> <span style="color:#000">{</span>
			<span style="color:#177500">// 新建并缓存ObjectFactory
</span><span style="color:#177500"></span>			<span style="color:#000">addSingletonFactory</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#a90d91">new</span> <span style="color:#000">ObjectFactory</span><span style="color:#000">&lt;</span><span style="color:#000">Object</span><span style="color:#000">&gt;()</span> <span style="color:#000">{</span>
				<span style="color:#000">@Override</span>
				<span style="color:#a90d91">public</span> <span style="color:#000">Object</span> <span style="color:#000">getObject</span><span style="color:#000">()</span> <span style="color:#a90d91">throws</span> <span style="color:#000">BeansException</span> <span style="color:#000">{</span>
					<span style="color:#177500">// 如果忽略BeanPostProcessor逻辑， 该方法实际就是直接返回bean对象
</span><span style="color:#177500"></span>					<span style="color:#177500">// 而这里的bean对象就是前面实例化的对象
</span><span style="color:#177500"></span>					<span style="color:#a90d91">return</span> <span style="color:#000">getEarlyBeanReference</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">bean</span><span style="color:#000">);</span>
				<span style="color:#000">}</span>
			<span style="color:#000">});</span>
		<span style="color:#000">}</span>

		<span style="color:#000">...</span>
		<span style="color:#177500">// 依赖注入
</span><span style="color:#177500"></span>    <span style="color:#000">populateBean</span><span style="color:#000">(</span><span style="color:#000">beanName</span><span style="color:#000">,</span> <span style="color:#000">mbd</span><span style="color:#000">,</span> <span style="color:#000">instanceWrapper</span><span style="color:#000">);</span>
		<span style="color:#000">...</span>
	<span style="color:#000">}</span>
<span style="color:#000">}</span>
</code></pre></div><p>如果你仔细看了上面的代码片段，相信你已经找到 Spring 处理循环依赖的关键点了</p>
<p>我们以 A，B 循环依赖注入为例，画了一个完整的注入流程图</p>
<p><img src="img/circular-di.png" alt="image-20190821155744858"></p>
<p>注意上图的<strong>黄色节点</strong>， 我们再来过一下这个流程</p>
<ol>
<li>在创建 A 的时候，会将 <strong>实例化的A</strong> 通过 <code>addSingleFactory</code>（黄色节点）方法缓存, 然后执行依赖注入B。</li>
<li>注入会走创建流程， 最后B又会执行依赖注入A。</li>
<li>由于第一步已经缓存了 A 的引用， 再次创建 A 时可以通过 <code>getSingleton</code> 方法得到这个 A 的提前引用（拿到最开始缓存的 objectFactory， 通过它取得对象引用）， 这样 B 的依赖注入就完成了。</li>
<li>B 创建完成后， 代表 A 的依赖注入也完成了，那么 A 也创建成功了 （实际上 Spring 还有 initial 等步骤，不过与我们这次的讨论主题相关性不大）</li>
</ol>
<p>这样整个依赖注入的流程就完成了</p>
<h2 id="总结">总结</h2>
<p>又到了总结的时候了，虽然全文铺的有点长，但是 Spring 处理单例 Bean 的循环依赖却并不复杂，而且稍微扩展一下，我们还可以将这样的处理思路借鉴一下从而处理类似的问题。</p>
<p>不可避免的文章还是留下了不少坑，比如</p>
<ul>
<li>我没有详细解释构造器注入为什么不能处理循环依赖</li>
<li>我没有详细说明 Spring 如何检测循环依赖的细节</li>
<li>我也没有说明 prototype 的 Bean 为什么不能处理循环依赖</li>
<li>&hellip;..</li>
</ul>
<p>当然这些都能在 Spring 创建 Bean 的流程里面找到（getBean(String) 方法），细节的东西就留给读者自己去源码里面发现了哦</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Circular_dependency">Circular_dependency</a></li>
</ol>

            </section>

            <div class="over">
                <div class="line"></div>
                <span>over</span>
                <div class="line"></div>
            </div>
        </article>

        
        <div>
            <script src="https://utteranc.es/client.js"
repo='vran-dev/vran-dev.github.io'
issue-term="pathname"
label="Comment"
theme="github-light"
crossorigin="anonymous"
async>

</script>
        </div>
        

    </section>
    <footer id="footer">
    <p>
        
        © 2021 <i></i> vran
        
        ∘ Powered by <a href="http://www.gohugo.io/">Hugo</a>  ∘  Theme <a href="https://github.com/vran-dev/ZenHo">ZenHo</a>
    </p>
</footer>


</body>
