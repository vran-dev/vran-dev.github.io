<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

		
		<meta name="google-site-verification" content="WQzn_X1rrhY2HHCuTYlY750m0YcuY3H73Z3T-OFsDOM" />
        

		<meta name="author" content="vran">
		
		<meta name="generator" content="Hugo 0.81.0" />
		<title>Java 模块化系统 Jigsaw &middot; 且徐行</title>
		<link rel="shortcut icon" href="https://blog.cc1234.cc/images/favicon.ico">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/style.css">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/highlight.css">
</head>


<body>
    <section id="single" class="wrapper">
    <nav class="nav-main" style="display: flex;">
         <div style="margin-left:auto;">
            
            <a href='https://blog.cc1234.cc/'> Home</a>
            <a href='https://blog.cc1234.cc/posts'>Archive</a> 
            <a href='https://blog.cc1234.cc/tags'>Tags</a> 
            <a href='https://blog.cc1234.cc/about'>About</a>
   
           
         </div>
</nav>

        <article class = "post">
            <header>
                <div class = "post-img">
                    
                </div>
                <div class = "title" >
                    Java 模块化系统 Jigsaw
                </div>
                <div class="meta">
                2019/10/24
                · vran
                </div>
            </header>
            <div class = "line"></div>
            
            <section class="content">
                <h2 id="历史">历史</h2>
<p>2017年9月21日  Java9  正式发布，其中最大的变化就是引入了代号为 Jigsaw 的模块化系统（Java Platform Module System，简称 JPMS）。</p>
<p>Java 的模块化系统可以说是一波三折，在 2005 年（Java7） 就已经有提案了（ <a href="https://jcp.org/en/jsr/detail?id=277">JSR277</a> ），但是因为种种历史原因，在一年多后该提案又被取消掉了</p>
<p><img src="img/jsr277.png" alt="image-20191017092549901"></p>
<p>直到 2014年，新的提案 <a href="https://jcp.org/en/jsr/detail?id=376">JSR376</a> 被提出，Java 的模块化系统才得以重新步入正轨，虽然它迟到了（原计划于 Java8 发布），但并没有缺席。</p>
<p>下图展示了从 JSR376 被提出到实现的各个阶段：</p>
<p><img src="img/jsr376.png" alt="image-20191017092615521"></p>
<h2 id="目标">目标</h2>
<p>在 <a href="https://www.jcp.org/en/jsr/detail?id=376">JSR376</a> 中，对模块化系统的目标是有非常明确的描述的：</p>
<ul>
<li>使用更可靠的配置来描述程序组件之间的依赖关系，并以此替代问题频出的 class-path</li>
<li>组件可以控制其 API 被其他组件的访问性，提供一个更强的封装能力</li>
<li>增加 JavaSE 平台的扩展性，开发人员可以只将他需要的功能模块组装到一个自定义的配置中去</li>
<li>增强平台的完整性，确保平台内部 API 不会被访问</li>
<li>性能提升</li>
</ul>
<p>实际上最核心的目标是最前面的两点，替代 class-path 和 增强封装性。</p>
<blockquote>
<p>在  <a href="http://openjdk.java.net/projects/jigsaw/goals-reqs/03">Project Jigsaw: Goals &amp; Requirements <strong>DRAFT 3</strong></a> 里对于实现目标的描述可能更加通俗易懂一些。</p>
</blockquote>
<p>初次接触 Java9 的模块化系统时，会不自觉的和 Maven、Gradle 等构建工具进行对比，但是实际上两者关注的核心点是不一样的。</p>
<p>模块化系统更注重模块之间的封装性，而构建工具更注重的是依赖管理和项目构建。</p>
<p>也就是说构建工具可以决定依赖某个第三方库，而模块系统则决定你能使用该第三方库的哪些包或类，两者并不是对立的。</p>
<p>这也恰好解释了为什么 Java 的模块化系统没有版本管理</p>
<h2 id="语法">语法</h2>
<p>Java 的模块是在 package 之上提供的一层抽象，所以通常一个模块是由多个 package 聚合而成的。</p>
<p>那么如何定义一个模块呢？</p>
<p>只需要在项目下创建一个 <strong>module-info.java</strong> 的文件，该文件所在包及其子包就组成了一个模块。</p>
<p><strong>module-info.java</strong>  描述了模块的以下信息：</p>
<ul>
<li>
<p>模块名称</p>
</li>
<li>
<p>依赖的其他模块</p>
</li>
<li>
<p>该模块下的封装信息（类的访问，反射权限）</p>
</li>
<li>
<p>该模块下的服务提供者和服务消费者信息（SPI）</p>
</li>
</ul>
<p>下面是摘自 <code>《 Java 语言规范 》</code> 的 模块定义语法：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#177500">// 以大括号标注的是占位符
</span><span style="color:#177500">// 以中括号标注的是可选项
</span><span style="color:#177500">// module, requires, exports, opens, provides..with, transitive, static 等都是关键字
</span><span style="color:#177500"></span>    
<span style="color:#000">{</span><span style="color:#000">Annotation</span><span style="color:#000">}</span> <span style="color:#000">[</span><span style="color:#000">open</span><span style="color:#000">]</span> <span style="color:#000">module</span> <span style="color:#000">Identifier</span> <span style="color:#000">{.</span> <span style="color:#000">Identifier</span><span style="color:#000">}</span> <span style="color:#000">{</span> 
  
  <span style="color:#000">{</span><span style="color:#000">ModuleDirective</span><span style="color:#000">}</span>
  
<span style="color:#000">}</span>
<span style="color:#000">
</span><span style="color:#000">ModuleDirective:</span>
  <span style="color:#000">requires</span> <span style="color:#000">{</span><span style="color:#000">RequiresModifier</span><span style="color:#000">}</span> <span style="color:#000">ModuleName</span> <span style="color:#000">;</span>
  <span style="color:#000">exports</span> <span style="color:#000">PackageName</span> <span style="color:#000">[</span><span style="color:#000">to</span> <span style="color:#000">ModuleName</span> <span style="color:#000">{,</span> <span style="color:#000">ModuleName</span><span style="color:#000">}]</span> <span style="color:#000">;</span>
  <span style="color:#000">opens</span> <span style="color:#000">PackageName</span> <span style="color:#000">[</span><span style="color:#000">to</span> <span style="color:#000">ModuleName</span> <span style="color:#000">{,</span> <span style="color:#000">ModuleName</span><span style="color:#000">}]</span> <span style="color:#000">;</span>
  <span style="color:#000">uses</span> <span style="color:#000">TypeName</span> <span style="color:#000">;</span>
  <span style="color:#000">provides</span> <span style="color:#000">TypeName</span> <span style="color:#000">with</span> <span style="color:#000">TypeName</span> <span style="color:#000">{,</span> <span style="color:#000">TypeName</span><span style="color:#000">}</span> <span style="color:#000">;</span>
<span style="color:#000">
</span><span style="color:#000">RequiresModifier:</span>
  <span style="color:#000">(</span><span style="color:#000">one</span> <span style="color:#000">of</span><span style="color:#000">)</span>
  <span style="color:#000">transitive</span> <span style="color:#a90d91">static</span>
</code></pre></div><p>下面来简单的过一遍</p>
<h3 id="module">Module</h3>
<p><strong>module</strong>  与 <code>class</code> 、<code>interface</code> 等关键词类似，只不过它是专门用来定义模块的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#177500">// 定义一个名称为 MyModule 的模块
</span><span style="color:#177500"></span><span style="color:#000">module</span> <span style="color:#000">MyModule</span> <span style="color:#000">{</span>
  
<span style="color:#000">}</span>
</code></pre></div><p>注意，一个 <strong>module-info.java</strong> 文件中只能出现一次 <strong>module</strong> 的定义， 它并不能像 class 或 interface 一样能在单个文件中多次定义。</p>
<p>为了让注解能作用于 <strong>module</strong> 之上，Java 9 特地为 <code>ElementType</code> 扩展了一个 <strong>MODULE</strong> 类型</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#177500">/**
</span><span style="color:#177500">* 一个可以修饰 module 的注解
</span><span style="color:#177500">*/</span>
<span style="color:#000">@Target</span><span style="color:#000">({</span><span style="color:#000">ElementType</span><span style="color:#000">.</span><span style="color:#836c28">MODULE</span><span style="color:#000">})</span>
<span style="color:#000">@Retention</span><span style="color:#000">(</span><span style="color:#000">RetentionPolicy</span><span style="color:#000">.</span><span style="color:#836c28">RUNTIME</span><span style="color:#000">)</span>
<span style="color:#000">@interface</span> <span style="color:#000">ModuleAnnotation</span> <span style="color:#000">{</span>

<span style="color:#000">}</span>
</code></pre></div><p><strong>module</strong> 前有一个可选关键字 open</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">open</span> <span style="color:#000">module</span> <span style="color:#000">MyModule</span> <span style="color:#000">{</span>
  <span style="color:#177500">//......
</span><span style="color:#177500"></span><span style="color:#000">}</span>
</code></pre></div><p>在 <code>《Java 语言规范》</code> 中，将被 <strong>open</strong> 修饰的模块定义为 <strong>开放模块</strong>，否则就是 <strong>标准模块</strong>。</p>
<p>两种模块之间的区别主要在于类的访问性上</p>
<ul>
<li><strong>开放模块</strong>：其他组件在<strong>编译时</strong>只能访问该模块明确 exports 的包下的类，但是在<strong>运行时</strong>可以访问该模块下所有的类</li>
<li><strong>标准模块</strong>：其他组件在<strong>编译时和运行时</strong>只能访问该模块明确 exoprts 的包下的类</li>
</ul>
<p>exports 关键字会在后面谈到</p>
<blockquote>
<p>更多信息可以参考《Java 语言规范》 7.7 Module Declarations</p>
</blockquote>
<h3 id="exports"><strong>Exports</strong></h3>
<p>前面说开放模块和标准模块的区别时提到了 <strong>exports</strong> 关键字，**exports ** 是 module 结构体内的一个指令，后面会跟上一个包名，表示该包下的所有类可以在编译期和运行时被其他模块访问。</p>
<p>比如下面的代码就是开放 <strong>MyExportModule</strong> 下 <strong>com.sample</strong> 包下所有的类的访问权限给第三方模块</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">MyExportsModule</span> <span style="color:#000">{</span>
  <span style="color:#000">exports</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>有时候我们还想更细粒度的 <strong>exports</strong>，就可以通过  <code> exports...to...</code>  明确指定允许访问的第三方组件， 相当于从群聊变成了私聊。</p>
<p>如下， <strong>com.sample</strong> 下的类只能被模块 <strong>B</strong> 访问。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
  <span style="color:#000">exports</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span> <span style="color:#000">to</span> <span style="color:#000">B</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><h3 id="opens">Opens</h3>
<p><strong>opens</strong> 与 <strong>exports</strong> 类似，主要区别在于 <strong>opens</strong> 是只针对于<strong>运行时访问能力</strong>的一个指令。</p>
<p><strong>opens</strong> 后面仍然是指定包名，该包下的类第三方组件是不可以直接引用的（即无法通过 import 使用），但是却可以通过反射进行调用。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">MyOpensModule</span> <span style="color:#000">{</span>
  <span style="color:#000">opens</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span>
<span style="color:#000">}</span>
</code></pre></div><p>与 <strong>exports</strong> 一样， <strong>opens</strong> 也可以通过  <strong>to</strong> 关键字指定具体的模块：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
	<span style="color:#000">opens</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span> <span style="color:#000">to</span> <span style="color:#000">B</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>需要注意一点就是，如果你的模块是开放模块，就不需要再使用 <strong>opens</strong> 了，用了也会产生编译错误的。</p>
<h3 id="requires">Requires</h3>
<p>前面说的 <strong>exports</strong> 和 <strong>opens</strong> 都是控制模块内部的访问权限的，那么如何依赖第三方模块呢？</p>
<p>这就轮到 <strong>requires</strong> 上场 了，它的作用类似于 maven 的 <!-- raw HTML omitted --> 标签，不过两者的含义可不同。</p>
<p>maven 和 gradle 这样的构建工具会从网络或本地将依赖导入到工作目录的 class-path 中，而模块化系统并不会从远程下载依赖，它更多是控制你是否有访问其他模块下相关类的能力。</p>
<p>比如我现在通过 maven 导入了 slf4j 的依赖，当我通过 import 引用 slf4j 包下的类时就会报错</p>
<p><img src="img/import-error.png" alt="image-20200529102238283"></p>
<p>IDEA 很友好的提示了需要先 requires 该组件</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">Sample</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">org</span><span style="color:#000">.</span><span style="color:#836c28">slf4j</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>为了使用方便， 用户定义的模块都会默认 <code>requires java.base</code>，我们自己也可以显示的去覆盖它。</p>
<p><strong>requires</strong> 后面还可以跟 <strong>transitive</strong> 或 <strong>static</strong> 关键字</p>
<ul>
<li>transitive  代表依赖可以被传递（默认依赖是不传递的， 官方也不推荐使用 transitive）</li>
<li>static 代表依赖的模块在编译期是必须的，在运行时是可选的 （ 比如 <a href="https://projectlombok.org/">lombok</a> ）</li>
</ul>
<p>下面用一段具体的实例来展示依赖传递</p>
<p>(1)、A 依赖 B</p>
<p>(2)、B 依赖 C，并且依赖关系是 transitive，这样的话 A 就隐式依赖了 C</p>
<p>(3)、C 依赖 lombok，并且依赖关系是 static 的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">B</span><span style="color:#000">;</span>
<span style="color:#000">}</span>

<span style="color:#000">module</span> <span style="color:#000">B</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">transitive</span> <span style="color:#000">C</span><span style="color:#000">;</span>
  <span style="color:#000">exports</span> <span style="color:#000">B</span><span style="color:#000">.</span><span style="color:#836c28">sample</span>
<span style="color:#000">}</span>

<span style="color:#000">mobule</span> <span style="color:#000">C</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#a90d91">static</span> <span style="color:#000">lombok</span><span style="color:#000">;</span>
  <span style="color:#000">opens</span> <span style="color:#000">C</span><span style="color:#000">.</span><span style="color:#836c28">sample</span>
<span style="color:#000">}</span>
</code></pre></div><p>如果没有使用 transitive，但是模块 A 又需要 模块 C 的话，就必须要再模块 A 中显示的指定依赖关系，否则的话会有编译错误</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">B</span><span style="color:#000">;</span>
  <span style="color:#000">required</span> <span style="color:#000">C</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><h3 id="uses--provideswith">Uses &amp; Provides&hellip;with</h3>
<p>模块化系统对 JAVA 的 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">SPI</a> 机制也做出了巨大的改变，而 Uses 和 Provides..with 就是针对 SPI 的关键字。</p>
<blockquote>
<p>SPI 本质上就是运行时动态的在 class-path 路径下加载对应的实现类的一种技术，它可以解耦<strong>服务消费者</strong>和<strong>服务提供者</strong></p>
</blockquote>
<p>我在组件 A 中定义了一个接口 <strong>Serializer</strong>，并创建了一个工厂 <strong>SerializerFactory</strong> 通过 SPI 机制加载接口的实现类</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">interface</span> <span style="color:#3f6e75">Serializer</span> <span style="color:#000">{</span>
  <span style="color:#a90d91">byte</span><span style="color:#000">[]</span> <span style="color:#000">serialize</span><span style="color:#000">(</span><span style="color:#000">Object</span> <span style="color:#000">target</span><span style="color:#000">);</span>
<span style="color:#000">}</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">SerializerFactory</span> <span style="color:#000">{</span>
  <span style="color:#a90d91">public</span> <span style="color:#a90d91">static</span> <span style="color:#000">List</span><span style="color:#000">&lt;</span><span style="color:#000">Serializer</span><span style="color:#000">&gt;</span> <span style="color:#000">getSerializers</span><span style="color:#000">()</span> <span style="color:#000">{</span>
        <span style="color:#a90d91">final</span> <span style="color:#000">ServiceLoader</span><span style="color:#000">&lt;</span><span style="color:#000">Serializer</span><span style="color:#000">&gt;</span> <span style="color:#000">loader</span> <span style="color:#000">=</span> <span style="color:#000">ServiceLoader</span><span style="color:#000">.</span><span style="color:#836c28">load</span><span style="color:#000">(</span><span style="color:#000">Serializer</span><span style="color:#000">.</span><span style="color:#836c28">class</span><span style="color:#000">);</span>
        <span style="color:#a90d91">return</span> <span style="color:#000">loader</span><span style="color:#000">.</span><span style="color:#836c28">stream</span><span style="color:#000">()</span>
          <span style="color:#000">.</span><span style="color:#836c28">map</span><span style="color:#000">(</span><span style="color:#000">ServiceLoader</span><span style="color:#000">.</span><span style="color:#836c28">Provider</span><span style="color:#000">::</span><span style="color:#000">get</span><span style="color:#000">)</span>
          <span style="color:#000">.</span><span style="color:#836c28">collect</span><span style="color:#000">(</span><span style="color:#000">Collectors</span><span style="color:#000">.</span><span style="color:#836c28">toList</span><span style="color:#000">());</span>
    <span style="color:#000">}</span>
<span style="color:#000">}</span>
</code></pre></div><p>在组件 B 中定义了定义了实现类 <strong>JdkSerializer</strong> ，并根据 SPI 的规则创建配置文件 com.sample.Serializer 并写入 <strong>JdkSerializer</strong> 的全限定名</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">- resources
	- META-INF
		- services
			com.sample.Serializer
</code></pre></div><p>这样就完成了 SPI 的整个配置， 但是在模块化系统中接口和实现的配置全部转到了 module-info.java 文件中。</p>
<p>首先在组件 A 中要用 <strong>uses</strong> 明确指定 Serializer 为服务提供者</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
  <span style="color:#177500">// Serializer 和 SerializerFactory 都在该包下
</span><span style="color:#177500"></span>	<span style="color:#000">exports</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span><span style="color:#000">;</span>
  <span style="color:#000">uses</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span><span style="color:#000">.</span><span style="color:#836c28">Serializer</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>如果不适用 uses 指定的话，SerializerFactory.getSerializers() 就会抛出异常</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">java.util.ServiceConfigurationError: com.sample.SerializerFactory: module A does not <span style="color:#a90d91">declare</span> <span style="color:#c41a16">`</span>uses<span style="color:#c41a16">`</span>
</code></pre></div><p>模块 B 依赖模块 A，并为 Serializer 提供实现类，同样需要通过 <strong>provides&hellip;with</strong>  来指定服务的实现类（不再需要创建 com.sample.Serializer 文件了）</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">B</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">A</span><span style="color:#000">;</span>
  <span style="color:#000">provides</span> <span style="color:#000">Serializer</span> <span style="color:#000">with</span> <span style="color:#000">HessianSerializer</span><span style="color:#000">,</span> <span style="color:#000">JdkSerializer</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p><code>provides A with B</code> 可以这样去理解， 为接口 A 提供实现类 B。</p>
<h2 id="类加载器">类加载器</h2>
<p>谈完了语法，再来看看模块化系统为<strong>类加载器</strong>带来的变化。</p>
<p>双亲委派模型没有变， 但是<strong>ExtClassLoader</strong> 更名为 <strong>PlatformClassLoader</strong>，还有 <strong>ApplicationClassLoader</strong> 除了可以加载 class-path 的类以外，还支持 module-path 的类路径加载。</p>
<p><img src="img/classloader.png" alt="image-20191022144513215"></p>
<h2 id="实例">实例</h2>
<p>在只有 class-path 的时代，我们用 <code>javac</code> 命令编译时会通过 classpath 参数指定依赖类路径， 使用 <code>java</code> 命令运行时也会通过 cp 参数指定类路径</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">javac --classpath

java -cp
</code></pre></div><p>下面通过一个简单的示例来展示这两个命令在模块化系统中的应用</p>
<p>在项目 module-sample 下，module-A 和 module-B 分别代表两个模块，mods 是用来存放编译输出的目录。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">module-sample/module-A/src
module-sample/module-B/src
module-sample/mods
</code></pre></div><p>模块 A 的目录结构如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">module-A/src/com/sample/Test.java
module-A/src/module-info.java
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">pakcage</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span><span style="color:#000">;</span>

<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">Test</span> <span style="color:#000">{</span>
	<span style="color:#a90d91">public</span> <span style="color:#a90d91">void</span> <span style="color:#000">say</span><span style="color:#000">(</span><span style="color:#000">String</span> <span style="color:#000">word</span><span style="color:#000">)</span> <span style="color:#000">{</span>
    	<span style="color:#000">System</span><span style="color:#000">.</span><span style="color:#836c28">out</span><span style="color:#000">.</span><span style="color:#836c28">println</span><span style="color:#000">(</span><span style="color:#000">word</span><span style="color:#000">);</span>
    <span style="color:#000">}</span>  
<span style="color:#000">}</span>

</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">A</span> <span style="color:#000">{</span>
  <span style="color:#000">exports</span> <span style="color:#000">com</span><span style="color:#000">.</span><span style="color:#836c28">sample</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>编译模块 A</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">javac -d mods/A module-a/src/module-info.java module-a/src/com/sample/Test.java
</code></pre></div><p>模块 B 的解构如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">module-B/src/com/test/MyTest.java
module-B/src/module-info.java
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">package</span> <span style="color:#000">com.test</span><span style="color:#000">;</span>

<span style="color:#a90d91">public</span> <span style="color:#a90d91">class</span> <span style="color:#3f6e75">MyTest</span> <span style="color:#000">{</span>
  
  <span style="color:#a90d91">public</span> <span style="color:#a90d91">static</span> <span style="color:#a90d91">void</span> <span style="color:#000">main</span><span style="color:#000">(</span><span style="color:#000">String</span><span style="color:#000">[]</span> <span style="color:#000">args</span><span style="color:#000">)</span> <span style="color:#000">{</span>
    <span style="color:#000">System</span><span style="color:#000">.</span><span style="color:#836c28">out</span><span style="color:#000">.</span><span style="color:#836c28">println</span><span style="color:#000">(</span><span style="color:#c41a16">&#34;hello world&#34;</span><span style="color:#000">);</span>
  <span style="color:#000">}</span>
  
<span style="color:#000">}</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">module</span> <span style="color:#000">B</span> <span style="color:#000">{</span>
  <span style="color:#000">requires</span> <span style="color:#000">A</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>编译模块 B ，由于当前模块依赖了模块 A，所以需要指定 module-path，从而使得编译期可以找到 模块A。</p>
<blockquote>
<p><code>-d</code> 参数指定编译文件的输出目录</p>
<p><code>-p</code> 指定 module-path</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">javac -p mods -d mods/B module-b/src/module-info.java module-b/src/com/b/MyTest.java
</code></pre></div><p>运行 main 方法</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">java --module-path mods -m B/com.b.MyTest
</code></pre></div><h2 id="兼容性">兼容性</h2>
<p>虽然 Java9 发布已经有一段时间了，但即使是现在很多第三方库也还没有模块化，为了保证兼容性，当 module-path 下存在没有定义 module-info.java 文件的依赖时，JAVA 会自动将其转为 <strong>automatic-module</strong></p>
<ul>
<li>
<p>Automatic-module 的的模块名会根据 manifest文件的定义 或 jar名称来决定</p>
</li>
<li>
<p>Automatic-module 默认 exports 组件内所有包</p>
</li>
<li>
<p>Automatic-module 默认 opens 组件内所有包</p>
</li>
</ul>
<p>Automatic-module 只是权宜之计，因为依赖的库迁移到模块化系统后，它的模块名和封装性都可能会改变。</p>
<h2 id="最后">最后</h2>
<p>Jigsaw 项目中还有 <a href="https://docs.oracle.com/javase/10/tools/jlink.htm">jlink</a>， <a href="https://docs.oracle.com/javase/10/tools/jmod.htm">jmod</a>，<a href="https://docs.oracle.com/javase/10/tools/jdeps.htm#GUID-A543FEBE-908A-49BF-996C-39499367ADB4">jdeps</a> 等工具，它们都是应用于模块之上的工具。</p>
<p>尤其是 Jlink， 通过该工具你可以对 JDK 进行 “ 裁剪 ”，从而构建出拥有最小依赖集合的运行时环境。</p>
<blockquote>
<p>如果你的项目中有 automatic-module 的话，是无法通过 jlink 进行裁剪的</p>
</blockquote>
<p>这个裁剪对于 GUI 项目来说有着不小的诱惑，因为以后就不必要求客户端安装 JRE 了，分发出来的包就是可以直接运行的。</p>
<p>我在 <a href="https://github.com/vran-dev/PrettyZoo">PrettyZoo</a> 项目中使用 Jlink 构建了一个最小运行镜像，总共 44M 左右，效果还是非常不错的（通过插件解决了 jlink 不支持 automatic-module 的限制）。</p>
<blockquote>
<p>PrettyZoo 是一个 zookeeper  的 GUI，基于 JavaFx11 实现的，欢迎 start 或 issue。</p>
</blockquote>
<p>该项目最开始时基于 Java8 开发的，后面才迁移到了 Java11，也算是完整的踩了一遍迁移的各种坑，迁移相关的内容会在后续单独再写一篇文章。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Understanding Java 9 Modules</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/goals-reqs/03">Project Jigsaw: Goals &amp; Requirements</a></li>
<li><a href="https://openjdk.java.net/projects/jigsaw/spec/reqs/">Java Platform Module System: Requirements</a></li>
<li><a href="https://jcp.org/en/jsr/detail?id=277">JSR 277: Java Module System</a></li>
<li><a href="https://www.jcp.org/en/jsr/detail?id=376">JSR 376: Java Platform Module System</a></li>
<li><a href="http://cr.openjdk.java.net/~mr/jigsaw/spec/java-se-9-jls-diffs.pdf">Java9 语言规范</a></li>
<li><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#getPlatformClassLoader--">ClassLoader</a></li>
<li><a href="https://openjdk.java.net/projects/jigsaw/quick-start">Module System Quick-Start Guide</a></li>
<li><a href="https://docs.oracle.com/javase/10/tools/toc.htm">Java Platform, Standard Edition Tools Reference</a></li>
<li><a href="https://github.com/vran-dev/PrettyZoo">PrettyZoo</a></li>
</ol>

            </section>

            <div class="over">
                <div class="line"></div>
                <span>over</span>
                <div class="line"></div>
            </div>
        </article>
        <div class = "social">

    
        <a href="https://github.com/vran-dev">
            <svg t="1612751476854" class="social-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9196" width="22" height="22">
                <path d="M63.681087 516.285293c0 210.288698 144.593659 387.06044 340.109608 435.411104 8.963443 2.334559 18.979018-5.66029 18.685506-14.948855V740.533933c0-9.954615 5.899616-19.5096 16.818309-25.228593 11.097059-5.5474 8.380932-25.607902-3.738907-28.030515-56.790299-11.356705-105.233532-34.160427-139.233656-64.471315-33.930132-30.367333-53.245562-67.216792-53.245561-106.518217 0-27.359951 9.783022-53.611324 27.084499-77.566521a14.623733 14.623733 0 0 0 2.817728-8.365127v-142.999656l118.721594 63.536587c3.619244 1.971054 8.143864 2.291661 12.088231 0.889571 33.284403-9.868819 69.433946-14.890153 108.385412-14.890153 38.949208 0 75.096494 5.021334 108.385413 14.948856a15.36429 15.36429 0 0 0 12.146933-0.891829l118.662892-63.59529v142.91386a15.115932 15.115932 0 0 0 2.801922 8.42383c17.346633 23.925846 27.098046 50.235922 27.098047 77.564263 0 39.333033-19.268016 76.180235-53.200406 106.547568-34.043022 30.310888-82.5427 53.083-139.278811 64.471315-12.115324 2.363911-14.77049 22.42667-3.73665 27.971813 10.923209 5.723508 16.822825 15.240111 16.822825 25.23085v196.215867c-0.295771 9.28405 9.749156 17.281157 18.685505 14.948855C816.104564 903.343476 960.668872 726.517546 960.668872 516.285293c0-247.50392-201.00239-448.495021-448.492764-448.495021-247.50392 0-448.495021 200.991101-448.495021 448.495021z m448.495021-418.595052c231.37198 0 418.590537 187.236619 418.590537 418.595052 0 189.266376-126.779662 345.246091-298.995176 397.046664v-172.800282c0-11.970825-4.610416-22.60052-11.209949-31.769422 49.723403-13.666429 95.127645-35.156114 127.946942-64.471315 38.922115-34.600697 62.660564-78.952807 62.660564-128.005645 0-32.381285-11.794717-62.003545-29.897711-88.808078v-165.336015c0.085796-10.469392-13.314213-18.322-22.428928-13.068113l-137.34614 73.755365c-34.108498-9.254699-70.578648-15.840684-109.320139-15.840685-38.718913 0-75.277118 6.525025-109.322397 15.840685l-137.352913-73.726013c-9.094395-5.253887-22.510209 2.598721-22.424412 13.068113v165.336014c-18.116541 26.806791-29.899969 56.429051-29.899969 88.808079 0 49.025744 23.7678 93.375596 62.617665 127.978551 32.878 29.373903 78.32514 50.804886 127.962747 64.532275-6.572439 9.137293-11.185113 19.737637-11.185113 31.737813v50.482022c-32.584486 12.149191-54.015469 14.718561-67.275495 12.149191-14.291838-2.829016-21.999947-10.189425-30.787282-22.426671-17.70788-24.646082-35.083865-69.989364-92.546986-84.820814-19.547983-5.222278-26.161062 23.912299-7.475557 28.996852 45.081378 11.67957 53.972571 43.329329 75.638365 73.579256 10.889342 15.068519 26.497473 29.084905 49.578904 33.636619 19.227376 3.736649 42.498461 0.878282 72.863535-9.372104v90.600767c-172.156811-51.825409-298.995176-207.834475-298.995175-397.100851 0.009031-231.360691 187.24565-418.59731 418.604083-418.59731z" fill="#707070" p-id="9197"></path>
            </svg>  
        </a>
    

    
        <a href='#'>
            <svg t="1612751098681" class="social-icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16516" width="22" height="22">
                <path d="M512.034307 0C229.72222 0 0.002375 229.655981 0.002375 512S229.72222 1024 512.034307 1024 1024.066239 794.344019 1024.066239 512 794.346394 0 512.034307 0z m0 989.89647C248.530253 989.89647 34.169769 775.504054 34.169769 512S248.530253 34.10353 512.034307 34.10353 989.898845 248.495946 989.898845 512 775.538361 989.89647 512.034307 989.89647z" fill="#828282" p-id="16517"></path><path d="M792.845583 353.808158a119.106898 119.106898 0 0 0 8.717476-20.532369 17.083697 17.083697 0 0 0-24.939005-19.893726 192.646626 192.646626 0 0 1-52.560309 21.490333 122.332044 122.332044 0 0 0-81.810154-31.517026 121.980791 121.980791 0 0 0-121.789198 126.866409 281.673444 281.673444 0 0 1-183.130847-101.480355 17.115629 17.115629 0 0 0-27.972558 2.235251 121.757266 121.757266 0 0 0-2.107522 118.819508 20.053387 20.053387 0 0 0-6.833478 2.490707 18.233254 18.233254 0 0 0-8.430087 15.359362c0 36.242984 16.125733 69.516278 42.118499 92.124236l-1.117625 1.117625a17.051765 17.051765 0 0 0-3.448672 16.54085 121.853062 121.853062 0 0 0 69.739803 75.519521 195.871772 195.871772 0 0 1-108.760883 18.488712 17.403019 17.403019 0 0 0-18.073594 11.240115 17.115629 17.115629 0 0 0 6.865411 20.117251 314.244231 314.244231 0 0 0 169.847075 49.782212c197.340651 0 315.297992-160.299364 315.297992-315.266059l-0.031932-5.236872a227.420731 227.420731 0 0 0 49.207434-53.007359 17.083697 17.083697 0 0 0-20.787826-25.258326z m-55.721591 56.040913a17.083697 17.083697 0 0 0-7.088936 14.720718c0.191593 4.215043 0.287389 8.49395 0.287389 12.708994 0 138.20232-105.152551 281.16253-281.130598 281.162529a279.725583 279.725583 0 0 1-92.1881-15.582886 225.856056 225.856056 0 0 0 97.233379-44.385681 17.083697 17.083697 0 0 0-10.218286-30.495197 87.877261 87.877261 0 0 1-70.059124-37.105152c8.078832-0.542846 15.998004-1.883997 23.693651-3.959586a17.051765 17.051765 0 0 0-1.149558-33.20943 87.526007 87.526007 0 0 1-66.450792-60.830734c8.49395 2.139454 17.211426 3.384807 25.928901 3.672196 7.504054-0.031932 14.465261-4.630161 16.796308-11.846825s-0.415118-15.167768-6.769614-19.382812a87.685668 87.685668 0 0 1-36.498441-94.040164 315.585381 315.585381 0 0 0 209.730323 94.902332c5.620057 0.031932 10.537608-1.979793 13.954347-6.099039s4.725957-9.579643 3.512536-14.816515a87.813397 87.813397 0 0 1 149.506299-80.021954 17.083697 17.083697 0 0 0 15.774479 5.077211c5.268804-1.053761 10.473743-2.267182 15.614819-3.672196a81.043782 81.043782 0 0 1-7.216665 4.821753 17.083697 17.083697 0 0 0 10.793065 31.548959l5.81165-0.734439a178.979668 178.979668 0 0 1-9.867032 7.567918z" fill="#828282" p-id="16518"></path>
            </svg>
        </a>
    

    
        <a href='#' >
            <svg t="1612751005803" class="social-icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13371" width="22" height="22">
                <path d="M512.034307 0C229.72222 0 0.002375 229.655981 0.002375 512S229.72222 1024 512.034307 1024 1024.066239 794.344019 1024.066239 512 794.346394 0 512.034307 0z m0 989.89647C248.530253 989.89647 34.169769 775.504054 34.169769 512S248.530253 34.10353 512.034307 34.10353 989.898845 248.495946 989.898845 512 775.538361 989.89647 512.034307 989.89647z" fill="#828282" p-id="13372"></path><path d="M623.796812 224.610702h-85.194961C430.096425 223.525009 416.237875 290.678309 416.237875 363.355869V416.203567h-47.898217a14.209804 14.209804 0 0 0-15.966072 15.966073v95.796432a14.209804 14.209804 0 0 0 15.966072 15.966072H416.237875v239.491082a14.337533 14.337533 0 0 0 16.061868 15.966072h97.552701c9.419983 1.085693 17.051765-6.54609 14.050143-15.966072L543.966451 543.932144h79.830361a14.209804 14.209804 0 0 0 15.966072-15.966072v-95.796432a14.209804 14.209804 0 0 0-15.966072-15.966073h-79.926157L543.966451 368.305351c3.097418-20.40464 3.097418-17.083697 22.03318-15.966072h57.126606c4.438568-0.989896 9.164525-0.44705 12.485468-3.672197 3.320943-3.225147 5.236872-7.631782 4.119247-12.293875v-95.796433A14.177872 14.177872 0 0 0 623.796812 224.610702z m-17.083697 94.008233l-40.042909-1.532743c-49.59062 0-53.741799 26.918798-53.741799 54.476238l-0.127728 60.543345a17.051765 17.051765 0 0 0 17.051765 17.083697H607.83074v61.692903h-77.914432a17.083697 17.083697 0 0 0-17.083697 17.051765L512.800679 767.457154H448.170019v-239.491082c0-9.419983-6.418361-17.051765-15.870276-17.051765H384.30573v-61.692902h47.994013a17.051765 17.051765 0 0 0 12.070351-4.981415c3.193214-3.225147 3.767993-7.567918 3.767993-12.102283v-68.81377c0-71.591867 14.465261-105.695397 90.431832-105.695398h68.111263v60.990396z" fill="#828282" p-id="13373"></path>
            </svg>
        </a>
    

    

</div>
        
        
        <div>
            <script src="https://utteranc.es/client.js"
repo='vran-dev/vran-dev.github.io'
issue-term="pathname"
label="Comment"
theme="github-light"
crossorigin="anonymous"
async>

</script>
        </div>
        

    </section>

    <footer id="footer">
    <p>
        
        © 2023 <i></i> vran
        
        ∘ Powered by <a href="http://www.gohugo.io/">Hugo</a>  ∘  Theme <a href="https://github.com/vran-dev/hugo-zenHo">ZenHo</a>
    </p>
</footer>


<script>
    var token = 'bacd84bd97ed2e6eef56ec4cae65acdb';
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?" + token;
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>


</body>
