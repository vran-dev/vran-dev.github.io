<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="vran">
		<meta name="description" content="且徐行">
		<meta name="generator" content="Hugo 0.80.0" />
		<title>操作系统之保护模式简谈 &middot; 且徐行</title>
		<link rel="shortcut icon" href="https://blog.cc1234.cc/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.cc1234.cc/css/style.css">
		<link rel="stylesheet" href="https://blog.cc1234.cc/css/highlight.css">

		
		<link rel="stylesheet" href="https://blog.cc1234.cc/css/monosocialiconsfont.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://blog.cc1234.cc/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blog.cc1234.cc/posts'>Archive</a>
	<a href='https://blog.cc1234.cc/tags'>Tags</a>
	<a href='https://blog.cc1234.cc/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        操作系统之保护模式简谈
                    </h1>
                    <h2 class="headline">
                    Dec 30, 2018 18:08
                    · 82 words
                    · 1 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://blog.cc1234.cc/tags/os">OS</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <h1 id="操作系统之保护模式简谈">操作系统之保护模式简谈</h1>
<h2 id="前言">前言</h2>
<p>如果你想学习或者自己尝试写一个操作系统<strong>内核</strong>，<a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>是你绕不开的一个话题。</p>
<p>这篇文章的主要目的是让你了解保护模式个东西，以及它的作用。</p>
<blockquote>
<p>不会涉及到如何进入保护模式，以及保护模式的一些细节我也会有意略过，</p>
</blockquote>
<p>希望你在读这篇文章的时候，能了解计算机的组成， 对CPU的寄存器体系有一定的了解。</p>
<h2 id="历史">历史</h2>
<p><strong>保护模式</strong>是CPU的一种运行模式，出现在<a href="https://zh.wikipedia.org/wiki/80286">80286</a>及之后的X86架构的CPU下。</p>
<blockquote>
<p>这里说的<strong>CPU运行模式</strong>主要体现在<strong>CPU</strong>在内存寻址的区别。</p>
</blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/80286">80286</a>之前只有一种运行模式， 由于<strong>保护模式</strong>和这种模式有非常大的区别， 为了便于区分，便将以前的运行模式称之为<strong>实模式</strong>， CPU默认是工作在<strong>实模式</strong>下的。</p>
<h3 id="实模式">实模式</h3>
<p>最开始的<strong>8086</strong>最大寻址空间为<code>1MB</code>(即2^20), 但是<strong>8086</strong>的内部寄存器只有16位，那么如何能够做到<code>1MB</code>的内存寻址呢？Intel采用了以下的方式</p>
<blockquote>
<p>内存地址 = 16位段寄存器 &laquo; 4 + 16位通用寄存器保存的地址偏移</p>
</blockquote>
<p>这样也会出现一个问题：即最终计算的内存地址会大于2^20 , 此时回产生内存回卷</p>
<blockquote>
<p>回卷就是把溢出的最高位1和低16位做加法运算。例如：原本是（1）0100101011000001，回卷就是0100101011000001+1=0100101011000010</p>
</blockquote>
<p>这个就是CPU默认的运行模式&ndash;实模式的最大特点了。</p>
<h3 id="保护模式">保护模式</h3>
<p><a href="https://zh.wikipedia.org/wiki/80286">80286</a>之后出现的保护模式，不仅仅改变了内存的寻址方式，还增加了<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E4%BF%9D%E8%AD%B7">存储器保护</a>，<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81">标签页</a>系统以及硬件支持的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>等特性。</p>
<p>为了兼容， 该模式默认是关闭的， 要由程序（通常是系统内核）主动切换。</p>
<p>为什么要有保护模式呢？因为<a href="https://zh.wikipedia.org/wiki/80286">80286</a>的内存寻址空间达到<code>16MB</code>， 而<a href="https://zh.wikipedia.org/wiki/Intel_80386">80386</a>更是达到了<code>4GB</code>, 实模式没法满足寻址的要求了。</p>
<p>下面我们就来讲一下<strong>保护模式</strong>是如何实现以上特性的。</p>
<p>在我们切换到<strong>保护模式</strong>之前我们要准备一个数据结构**<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8">全局描述符表</a>**， 它的本质是一个数组， 数组中的每一个元素称为**全局描述符**， 这是一个64位的数据结构。</p>
<blockquote>
<p>数据结构看着有点怪是不是？这其实是历史原因</p>
</blockquote>
<p><img src="img/global-descriptor.png" alt="global-descriptor"></p>
<p><strong>全局描述符</strong>包含可访问的内存的基址， 最大长度， 以及其他的一些权限位。</p>
<p><img src="img/gdt-01.png" alt="gdt-01"></p>
<p>这个全局描述符的地址被放在了一个称之为<code> GDTR</code>的寄存器中</p>
<p>现在的段寄存器存储的就是<strong>全局描述符表的</strong>索引， 我们一般称之为<strong>段选择子</strong></p>
<blockquote>
<p>实际上段选择子的高13位存储的是索引， 低3位用来存储和权限相关的bit, 可以参考下图</p>
</blockquote>
<p><img src="img/selector.png" alt="selector"></p>
<p>这样的话我们的寻址方式就变成了以下流程了</p>
<ol>
<li>从GDTR取得全局描述符表的地址</li>
<li>从段选择子取得索引 <strong>idx</strong>， 然后用 <code>idx * 64 + 全局描述符的地址</code> 得到 一个全局描述符的地址（前面我们讲过一个描述符是64bit的数据结构）</li>
<li>从全局描述符我们可以拿到内存的<code>BaseAddress</code>, 用<code>BaseAddress + 16位通用寄存器的偏移</code> 就可以得到最终的物理内存地址</li>
</ol>
<p>注意， 我有意跳过了相关的权限检查的流程， 参考下图(目前得到的线性地址-Linear address 就是物理内存地址)</p>
<p><img src="img/segment-translation.png" alt="segment-translation"></p>
<h2 id="总结">总结</h2>
<p><strong>保护模式</strong>不仅仅是寻址的改变， 其实它还有一个核心就是<strong>保护</strong>， 这里的保护值得就是权限的校验等等。</p>
<p>还有一点就是保护模式是实现<strong>页式内存管理</strong>的基础， 而<strong>内存分页</strong>又是<strong>虚拟内存的</strong>基础， 所以<strong>保护模式</strong>在操作系统层次还是有举足轻重的地位的。</p>

                </section>
            </article>

            

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/posts/java-biased-locking/"> 你知道为什么 Java 会放弃偏向锁吗？ <aside class="dates">Feb 1 2021</aside></a>
        </li>
    
        <li>
            <a href="/posts/how-to-develop-prettyzoo/">我是如何开发了一款‘有人用’的开源软件<aside class="dates">Nov 22 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/scala-adt/"> Scala 与 Algebraic data type<aside class="dates">Aug 18 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/typeclasses-deriving/"> Scala2 如何实现 Type class 派生<aside class="dates">Aug 15 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/vavr-1/"> VAVR：颠覆你的 Java 体验 <aside class="dates">Jul 25 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/typeclasses-2/">真的学不动了：Scala3 与 Type classes<aside class="dates">Jul 19 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/typeclasses-1/">真的学不动了：除了 class , 也该了解 Type classes 了<aside class="dates">Jul 15 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/polymorphism/">多态都不知道，谈什么对象<aside class="dates">May 27 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/xingren-wx-service-refactor/">一次微服务重构总结 <aside class="dates">May 10 2020</aside></a>
        </li>
    
        <li>
            <a href="/posts/spring-ant-matcher-note/">Spring Ant-Style Matcher 笔记<aside class="dates">May 4 2020</aside></a>
        </li>
    
</ul>

            
 <script src="https://utteranc.es/client.js"
           repo="vran-dev/vran-dev.github.io"
          issue-term="pathname"
           label="Comment"
           theme="github-light"
           crossorigin="anonymous"
           async>
   </script>

            <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://github.com/vran-dev">
        github
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2021 <i class="fa fa-heart" aria-hidden="true"></i> vran
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://blog.cc1234.cc/js/jquery-3.3.1.min.js"></script>
<script src="https://blog.cc1234.cc/js/main.js"></script>
<script src="https://blog.cc1234.cc/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
