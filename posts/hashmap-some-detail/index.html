<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        

		<meta name="author" content="vran">
		
		<meta name="generator" content="Hugo 0.80.0" />
		<title>HashMap 的细节笔记 &middot; 且徐行</title>
		<link rel="shortcut icon" href="https://blog.cc1234.cc/images/favicon.ico">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/style.css">
        <link rel="stylesheet" href="https://blog.cc1234.cc/css/highlight.css">
</head>


<body>
    <section id="single" class="wrapper">
    


<nav class="nav-main">
         
         <a href='https://blog.cc1234.cc/'> Home</a>
         <a href='https://blog.cc1234.cc/posts'>Archive</a> 
         <a href='https://blog.cc1234.cc/tags'>Tags</a> 
         <a href='https://blog.cc1234.cc/about'>About</a>

        
        
</nav>


        <article class = "post">
            <header>
                <div class = "post-img">
                    
                </div>
                <div class = title>
                    HashMap 的细节笔记
                </div>
                <div class="meta">
                2020/04/27
                · vran
                </div>
            </header>
            <div class = "line"></div>
            
            <section class="content">
                <h3 id="hashmap-的节点转为红黑树以后树形节点之间是基于什么来比较的呢"><strong>HashMap 的节点转为红黑树以后，树形节点之间是基于什么来比较的呢？</strong></h3>
<p>首先会根据 key 的 Hash 值来进行比较，如果相等的话，会再判断 key 是否实现了 <code>Comparable</code> 接口，如果是的话，可以直接通过 <code>compareTo</code> 方法进行比较。</p>
<p>如果 hash 值相等，而且也没有实现Comparable 接口呢？此时会对 key 对象使用 <code>System.identityHashCode(key)</code> 进行再次 hash 运算，最后再根据新的 hash 值进行比较。</p>
<p>那么 <code>System.identityHashCode</code> 又是什么操作呢？</p>
<p>这是一个 native 的方法，实现的原理也很简单，就是不管你对象有没重写 hashCode 函数，它都只返回对象默认的 hashCode 值。</p>
<h3 id="为什么-hashmap-的链表节点冲突数达到-8-才会转为红黑树"><strong>为什么 HashMap 的链表节点冲突数达到 8 才会转为红黑树？</strong></h3>
<p>在 hashmap 的源码注释中有一段 Implementation notes， 里面有提到具体的决策原因。</p>
<p>虽然红黑树的查询事件复杂度是 logN,  但是红黑树节点的 size 大概是普通节点的 2 倍，而且在插入效率方面，红黑树的插入时间复杂度为 logN, 链表的插入节点时间复杂度是 O (1)。</p>
<p>综上所述，实则是一个时间和空间的决策，那么为什么是 8 呢？</p>
<p>如果 key 的 hash 值分布的足够均匀，几乎不会转换成树形节点。</p>
<p>假设使用随机的 hash 算法，理想情况下，通过泊松分布的概率函数可以计算某个桶位冲突节点达到 K 个的概率，设 <code>λ = 0.75</code>, 带入以下公式</p>
<p><img src="img/poisson-distribution.svg" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">节点数(K)</th>
<th style="text-align:center">概率(P)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0.60653066</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0.30326533</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0.07581633</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0.01263606</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0.00157952</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0.00015795</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0.00001316</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0.00000094</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0.00000006</td>
</tr>
</tbody>
</table>
<p>节点数大于 8 的概率少于一千万分之一</p>
<h3 id="hashmap-的-capacity-为什么是-2-的次幂"><strong>HashMap 的 capacity 为什么是 2 的次幂？</strong></h3>
<p>我们都知道在构造 HashMap 的时候可以指定初始容量</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">public</span> <span style="color:#000">HashMap</span><span style="color:#000">(</span><span style="color:#a90d91">int</span> <span style="color:#000">initialCapacity</span><span style="color:#000">)</span>

<span style="color:#a90d91">public</span> <span style="color:#000">HashMap</span><span style="color:#000">(</span><span style="color:#a90d91">int</span> <span style="color:#000">initialCapacity</span><span style="color:#000">,</span> <span style="color:#a90d91">float</span> <span style="color:#000">loadFactor</span><span style="color:#000">)</span>
</code></pre></div><p>如果传入的 initialCapacity 不是 2 的 n 次方的话，HashMap 会调用 <code>tableSizeFor</code> 方法，该方法会返回大于 cap 的最小 2 次幂的值</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a90d91">static</span> <span style="color:#a90d91">final</span> <span style="color:#a90d91">int</span> <span style="color:#000">tableSizeFor</span><span style="color:#000">(</span><span style="color:#a90d91">int</span> <span style="color:#000">cap</span><span style="color:#000">)</span> <span style="color:#000">{</span>
  <span style="color:#a90d91">int</span> <span style="color:#000">n</span> <span style="color:#000">=</span> <span style="color:#000">-</span><span style="color:#000">1</span> <span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">Integer</span><span style="color:#000">.</span><span style="color:#836c28">numberOfLeadingZeros</span><span style="color:#000">(</span><span style="color:#000">cap</span> <span style="color:#000">-</span> <span style="color:#000">1</span><span style="color:#000">);</span>
  <span style="color:#a90d91">return</span> <span style="color:#000">(</span><span style="color:#000">n</span> <span style="color:#000">&lt;</span> <span style="color:#000">0</span><span style="color:#000">)</span> <span style="color:#000">?</span> <span style="color:#000">1</span> <span style="color:#000">:</span> <span style="color:#000">(</span><span style="color:#000">n</span> <span style="color:#000">&gt;=</span> <span style="color:#000">MAXIMUM_CAPACITY</span><span style="color:#000">)</span> <span style="color:#000">?</span> <span style="color:#000">MAXIMUM_CAPACITY</span> <span style="color:#000">:</span> <span style="color:#000">n</span> <span style="color:#000">+</span> <span style="color:#000">1</span><span style="color:#000">;</span>
<span style="color:#000">}</span>
</code></pre></div><p>为什么需要这样做呢？</p>
<ul>
<li>在计算索引时，可以用 &amp; 来替代 %</li>
<li>在 resize 时，可以更方便的对冲突节点进行处理</li>
</ul>
<p>先来看第一点</p>
<p>我们指的 capacity 实际就是 bucket.length，每一个 key 对应的索引是根据下面的公式进行计算的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-matlab" data-lang="matlab">   <span style="color:#000">index</span> = (<span style="color:#000">bucket</span>.<span style="color:#a90d91">length</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>) <span style="color:#000">&amp;</span> <span style="color:#000">hash</span>(<span style="color:#000">key</span>)
</code></pre></div><p>假设 capacity 保证为 2 的次幂，那么 <code>capacity - 1</code> 就可以保证该数的二进制低位全部为 1</p>
<p>比如</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">(</span><span style="color:#000">16</span> <span style="color:#000">-</span> <span style="color:#000">1</span><span style="color:#000">)</span> <span style="color:#000">=</span> <span style="color:#000">0000_0000_0000_1111</span>
<span style="color:#000">(</span><span style="color:#000">32</span> <span style="color:#000">-</span> <span style="color:#000">1</span><span style="color:#000">)</span> <span style="color:#000">=</span> <span style="color:#000">0000_0000_0001_1111</span>
<span style="color:#000">(</span><span style="color:#000">64</span> <span style="color:#000">-</span> <span style="color:#000">1</span><span style="color:#000">)</span> <span style="color:#000">=</span> <span style="color:#000">0000_0000_0011_1111</span>
</code></pre></div><p>那么 在与 <code>hash(key) </code> 进行 <code>&amp;</code> 运算，可以保证最终得到的结果范围符合 [0, buket.length - 1]，即</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#000">0</span> <span style="color:#000">&lt;=</span> <span style="color:#000">index</span> <span style="color:#000">&lt;=</span> <span style="color:#000">buket</span><span style="color:#000">.</span><span style="color:#836c28">length</span> <span style="color:#000">-</span> <span style="color:#000">1</span>
</code></pre></div><p>再来看 resize</p>
<p>众所周知，HashMap 在节点达到阈值时，会按当前容量的两倍进行扩容，也就是相当于当前容量值左移一位。</p>
<p>比如当前容量为 16，向左移位 1 位就是 32，对应的二进制位</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">16</span> <span style="color:#000">=</span> <span style="color:#000">0000_0000_0001_0000</span>
<span style="color:#000">32</span> <span style="color:#000">=</span> <span style="color:#000">0000_0000_0010_0000</span>  
</code></pre></div><p>扩容以后，节点需要进行 REHASH，结合前面提到的 hash 算法</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#000">index</span> <span style="color:#000">=</span> <span style="color:#000">(</span><span style="color:#000">bucket</span><span style="color:#000">.</span><span style="color:#836c28">length</span> <span style="color:#000">-</span> <span style="color:#000">1</span><span style="color:#000">)</span> <span style="color:#000">&amp;</span> <span style="color:#000">hash</span><span style="color:#000">(</span><span style="color:#000">key</span><span style="color:#000">)</span>
</code></pre></div><p>由于低位不变，只是高位变成了 1，这样的话，就可以把一段冲突的链表节点分为两部分，高位为 1 与 高位为 0。</p>
<p>假设新的容量为 32，两个节点 A 和 B 的 Hash 值如下</p>
<pre><code class="language-properties" data-lang="properties">A = 0000_0000_0000_1011
B = 0000_0000_0001_1011
</code></pre><p>那么新的索引</p>
<pre><code class="language-math" data-lang="math">index(A) = 11111 &amp; A = 1011 即 11
index(B) = 11111 &amp; B = 11011 即 27
</code></pre><p>很明显如果 index(B) = (old capacity - 1) + old index =  (16 - 1) + 11</p>
<p>而这个也是得益于 capacity 是 2 的 n 次方这一特性</p>

            </section>

            <div class="over">
                <div class="line"></div>
                <span>over</span>
                <div class="line"></div>
            </div>
        </article>

        
        <div>
            <script src="https://utteranc.es/client.js"
repo='vran-dev/vran-dev.github.io'
issue-term="pathname"
label="Comment"
theme="github-light"
crossorigin="anonymous"
async>

</script>
        </div>
        

    </section>
    <footer id="footer">
    <p>
        
        © 2021 <i></i> vran
        
        ∘ Powered by <a href="http://www.gohugo.io/">Hugo</a>  ∘  Theme <a href="https://github.com/vran-dev/ZenHo">ZenHo</a>
    </p>
</footer>


</body>
